{"mappings":"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","sources":["node_modules/@quilicicf/markdown-formatter/lib/formatFromString.js","node_modules/unified/lib/index.js","node_modules/bail/index.js","node_modules/is-buffer/index.js","node_modules/extend/index.js","node_modules/is-plain-obj/index.js","node_modules/trough/index.js","node_modules/vfile/lib/index.js","node_modules/vfile-message/lib/index.js","node_modules/unist-util-stringify-position/lib/index.js","node_modules/vfile/lib/minpath.js","node_modules/vfile/lib/minproc.js","node_modules/vfile/lib/minurl.shared.js","node_modules/vfile/lib/minurl.js","node_modules/remark-parse/index.js","node_modules/remark-parse/lib/index.js","node_modules/mdast-util-from-markdown/lib/index.js","node_modules/mdast-util-to-string/lib/index.js","node_modules/micromark/lib/parse.js","node_modules/micromark-util-combine-extensions/index.js","node_modules/micromark-util-chunked/index.js","node_modules/micromark/lib/initialize/content.js","node_modules/micromark-factory-space/index.js","node_modules/micromark-util-character/index.js","node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","node_modules/micromark/lib/initialize/document.js","node_modules/micromark/lib/initialize/flow.js","node_modules/micromark-core-commonmark/lib/blank-line.js","node_modules/micromark-core-commonmark/lib/content.js","node_modules/micromark-util-subtokenize/index.js","node_modules/micromark/lib/initialize/text.js","node_modules/micromark/lib/create-tokenizer.js","node_modules/micromark-util-resolve-all/index.js","node_modules/micromark/lib/constructs.js","node_modules/micromark-core-commonmark/lib/attention.js","node_modules/micromark-util-classify-character/index.js","node_modules/micromark-core-commonmark/lib/autolink.js","node_modules/micromark-core-commonmark/lib/block-quote.js","node_modules/micromark-core-commonmark/lib/character-escape.js","node_modules/micromark-core-commonmark/lib/character-reference.js","node_modules/decode-named-character-reference/index.js","node_modules/character-entities/index.js","node_modules/micromark-core-commonmark/lib/code-fenced.js","node_modules/micromark-core-commonmark/lib/code-indented.js","node_modules/micromark-core-commonmark/lib/code-text.js","node_modules/micromark-core-commonmark/lib/definition.js","node_modules/micromark-factory-destination/index.js","node_modules/micromark-factory-label/index.js","node_modules/micromark-factory-title/index.js","node_modules/micromark-factory-whitespace/index.js","node_modules/micromark-util-normalize-identifier/index.js","node_modules/micromark-core-commonmark/lib/hard-break-escape.js","node_modules/micromark-core-commonmark/lib/heading-atx.js","node_modules/micromark-core-commonmark/lib/html-flow.js","node_modules/micromark-util-html-tag-name/index.js","node_modules/micromark-core-commonmark/lib/html-text.js","node_modules/micromark-core-commonmark/lib/label-end.js","node_modules/micromark-core-commonmark/lib/label-start-image.js","node_modules/micromark-core-commonmark/lib/label-start-link.js","node_modules/micromark-core-commonmark/lib/line-ending.js","node_modules/micromark-core-commonmark/lib/list.js","node_modules/micromark-core-commonmark/lib/thematic-break.js","node_modules/micromark-core-commonmark/lib/setext-underline.js","node_modules/micromark/lib/preprocess.js","node_modules/micromark/lib/postprocess.js","node_modules/micromark-util-decode-numeric-character-reference/index.js","node_modules/micromark-util-decode-string/index.js","node_modules/remark-gfm/index.js","node_modules/micromark-extension-gfm/index.js","node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js","node_modules/micromark-extension-gfm-autolink-literal/lib/html.js","node_modules/micromark-util-sanitize-uri/index.js","node_modules/micromark-util-encode/index.js","node_modules/micromark-extension-gfm-footnote/lib/syntax.js","node_modules/micromark-extension-gfm-footnote/lib/html.js","node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","node_modules/micromark-extension-gfm-strikethrough/lib/html.js","node_modules/micromark-extension-gfm-table/lib/syntax.js","node_modules/micromark-extension-gfm-table/lib/html.js","node_modules/micromark-extension-gfm-tagfilter/index.js","node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js","node_modules/micromark-extension-gfm-task-list-item/lib/html.js","node_modules/mdast-util-gfm/lib/index.js","node_modules/mdast-util-gfm-autolink-literal/lib/index.js","node_modules/ccount/index.js","node_modules/mdast-util-find-and-replace/lib/index.js","node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","node_modules/unist-util-visit-parents/lib/index.js","node_modules/unist-util-is/lib/index.js","node_modules/unist-util-visit-parents/lib/color.js","node_modules/mdast-util-gfm-footnote/lib/index.js","node_modules/mdast-util-to-markdown/lib/util/association.js","node_modules/mdast-util-to-markdown/lib/util/container-flow.js","node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","node_modules/mdast-util-to-markdown/lib/util/safe.js","node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","node_modules/mdast-util-to-markdown/lib/util/track.js","node_modules/mdast-util-gfm-strikethrough/lib/index.js","node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","node_modules/mdast-util-gfm-table/lib/index.js","node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","node_modules/markdown-table/index.js","node_modules/mdast-util-gfm-task-list-item/lib/index.js","node_modules/mdast-util-to-markdown/lib/handle/list-item.js","node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","node_modules/remark-stringify/index.js","node_modules/remark-stringify/lib/index.js","node_modules/mdast-util-to-markdown/lib/index.js","node_modules/zwitch/index.js","node_modules/mdast-util-to-markdown/lib/configure.js","node_modules/mdast-util-to-markdown/lib/handle/index.js","node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","node_modules/mdast-util-to-markdown/lib/handle/break.js","node_modules/mdast-util-to-markdown/lib/handle/code.js","node_modules/longest-streak/index.js","node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","node_modules/mdast-util-to-markdown/lib/util/check-fence.js","node_modules/mdast-util-to-markdown/lib/handle/definition.js","node_modules/mdast-util-to-markdown/lib/util/check-quote.js","node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","node_modules/mdast-util-to-markdown/lib/handle/heading.js","node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","node_modules/unist-util-visit/lib/index.js","node_modules/mdast-util-to-markdown/lib/handle/html.js","node_modules/mdast-util-to-markdown/lib/handle/image.js","node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","node_modules/mdast-util-to-markdown/lib/handle/link.js","node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","node_modules/mdast-util-to-markdown/lib/handle/list.js","node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js","node_modules/mdast-util-to-markdown/lib/util/check-rule.js","node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","node_modules/mdast-util-to-markdown/lib/handle/root.js","node_modules/mdast-util-phrasing/lib/index.js","node_modules/mdast-util-to-markdown/lib/handle/strong.js","node_modules/mdast-util-to-markdown/lib/util/check-strong.js","node_modules/mdast-util-to-markdown/lib/handle/text.js","node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","node_modules/mdast-util-to-markdown/lib/join.js","node_modules/mdast-util-to-markdown/lib/unsafe.js","node_modules/@quilicicf/markdown-formatter/lib/remark-plugins/toc/index.js","node_modules/mdast-util-toc/lib/index.js","node_modules/mdast-util-toc/lib/search.js","node_modules/github-slugger/index.js","node_modules/github-slugger/regex.js","node_modules/mdast-util-toc/lib/to-expression.js","node_modules/mdast-util-toc/lib/contents.js","node_modules/unist-builder/lib/index.js","node_modules/@quilicicf/markdown-formatter/lib/remark-plugins/toc/findTocStart.js","node_modules/@quilicicf/markdown-formatter/lib/remark-plugins/toc/isTocStart.js","node_modules/@quilicicf/markdown-formatter/lib/constants.js","node_modules/@quilicicf/markdown-formatter/lib/remark-plugins/isTocEnd.js","node_modules/@quilicicf/markdown-formatter/lib/remark-plugins/toc/parseTocConfiguration.js","node_modules/@quilicicf/markdown-formatter/lib/matchAll.js","node_modules/@quilicicf/markdown-formatter/lib/isInRange.js","node_modules/@quilicicf/markdown-formatter/lib/remark-plugins/watermarkPlugin/index.js","node_modules/@quilicicf/markdown-formatter/lib/remark-plugins/watermarkPlugin/addWatermarkInTocEnd.js","node_modules/@quilicicf/markdown-formatter/lib/remark-plugins/watermarkPlugin/searchAndDestroyWatermarkTop.js"],"sourcesContent":["import { unified } from 'unified';\nimport parse from 'remark-parse';\nimport gfm from 'remark-gfm';\nimport stringify from 'remark-stringify';\n\nimport tocPlugin from './remark-plugins/toc/index.js';\nimport watermarkPlugin from './remark-plugins/watermarkPlugin/index.js';\nimport { DEFAULT_MARKDOWN_FORMATTER_OPTIONS, DEFAULT_STRINGIFY_OPTIONS } from './constants.js';\n\nexport default async (sourceString, parameterMarkdownFormatterOptions = {}, parameterStringifyOptions = {}) => {\n  const markdownFormatterOptions = {\n    ...DEFAULT_MARKDOWN_FORMATTER_OPTIONS,\n    ...parameterMarkdownFormatterOptions,\n  };\n  const stringifyOptions = {\n    ...DEFAULT_STRINGIFY_OPTIONS,\n    ...parameterStringifyOptions,\n  };\n\n  return unified()\n    .use(parse)\n    .use(gfm)\n    .use(tocPlugin)\n    .use(watermarkPlugin(markdownFormatterOptions.watermark))\n    .use(stringify, stringifyOptions)\n    .process(sourceString);\n};\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\nimport {bail} from 'bail'\nimport isBuffer from 'is-buffer'\nimport extend from 'extend'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\n\n// Expose a frozen processor.\nexport const unified = base().freeze()\n\nconst own = {}.hasOwnProperty\n\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */\nfunction base() {\n  const transformers = trough()\n  /** @type {Processor['attachers']} */\n  const attachers = []\n  /** @type {Record<string, unknown>} */\n  let namespace = {}\n  /** @type {boolean|undefined} */\n  let frozen\n  let freezeIndex = -1\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data\n  processor.Parser = undefined\n  processor.Compiler = undefined\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  // @ts-expect-error: overloads are handled.\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  // @ts-expect-error: overloads are handled.\n  processor.run = run\n  processor.runSync = runSync\n  // @ts-expect-error: overloads are handled.\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    const destination = base()\n    let index = -1\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      /** @type {Transformer|void} */\n      const transformer = attacher.call(processor, ...options)\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Number.POSITIVE_INFINITY\n\n    return processor\n  }\n\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value\n          addPlugin(plugin, ...options)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n    function addPlugin(plugin, value) {\n      let index = -1\n      /** @type {Processor['attachers'][number]|undefined} */\n      let entry\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index]\n          break\n        }\n      }\n\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments])\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n  function run(node, doc, callback) {\n    assertNode(node)\n    processor.freeze()\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc\n      doc = undefined\n    }\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` cant be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done)\n\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result\n\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n    function done(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n  function process(doc, callback) {\n    processor.freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      const file = vfile(doc)\n\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error)\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file)\n\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result\n          } else {\n            file.result = result\n          }\n\n          done(error, file)\n        }\n      })\n\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n\n    const file = vfile(doc)\n\n    processor.process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\nfunction keys(value) {\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value)\n}\n","/**\n * Throw a given error.\n *\n * @param {Error|null|undefined} [error]\n *   Maybe error.\n * @returns {asserts error is null|undefined}\n */\nexport function bail(error) {\n  if (error) {\n    throw error\n  }\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n","/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or were done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result instanceof Promise) {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Value} Value\n */\n\n/**\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\n *\n * @typedef {'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *\n *   This is a copy of the types from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {Options | URL | Value | VFile} Compatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n *   Set multiple values.\n * @property {Value | null | undefined} [value]\n *   Set `value`.\n * @property {string | null | undefined} [cwd]\n *   Set `cwd`.\n * @property {Array<string> | null | undefined} [history]\n *   Set `history`.\n * @property {URL | string | null | undefined} [path]\n *   Set `path`.\n * @property {string | null | undefined} [basename]\n *   Set `basename`.\n * @property {string | null | undefined} [stem]\n *   Set `stem`.\n * @property {string | null | undefined} [extname]\n *   Set `extname`.\n * @property {string | null | undefined} [dirname]\n *   Set `dirname`.\n * @property {Data | null | undefined} [data]\n *   Set `data`.\n *\n * @typedef Map\n *   Raw source map.\n *\n *   See:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n *   Which version of the source map spec this map is following.\n * @property {Array<string>} sources\n *   An array of URLs to the original source files.\n * @property {Array<string>} names\n *   An array of identifiers which can be referenced by individual mappings.\n * @property {string | undefined} [sourceRoot]\n *   The URL root from which all sources are relative.\n * @property {Array<string> | undefined} [sourcesContent]\n *   An array of contents of the original source files.\n * @property {string} mappings\n *   A string of base64 VLQs which contain the actual mappings.\n * @property {string} file\n *   The generated file this source map is associated with.\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\n *   Configuration.\n *\n *   A bunch of keys that will be shallow copied over to the new file.\n *\n * @typedef {Record<string, unknown>} ReporterSettings\n *   Configuration for reporters.\n */\n\n/**\n * @template {ReporterSettings} Settings\n *   Options type.\n * @callback Reporter\n *   Type for a reporter.\n * @param {Array<VFile>} files\n *   Files to report.\n * @param {Settings} options\n *   Configuration.\n * @returns {string}\n *   Report.\n */\n\nimport bufferLike from 'is-buffer'\nimport {VFileMessage} from 'vfile-message'\nimport {path} from './minpath.js'\nimport {proc} from './minproc.js'\nimport {urlToPath, isUrl} from './minurl.js'\n\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n *\n * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}\n */\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Buffer`  `{value: options}`\n   * *   `URL`  `{path: options}`\n   * *   `VFile`  shallow copies its data over to the new file\n   * *   `object`  all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(value) {\n    /** @type {Options | VFile} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (typeof value === 'string' || buffer(value)) {\n      options = {value}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else {\n      options = value\n    }\n\n    /**\n     * Place to store custom information (default: `{}`).\n     *\n     * Its OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */\n    this.data = {}\n\n    /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * List of filepaths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */\n    this.cwd = proc.cwd()\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Raw value.\n     *\n     * @type {Value}\n     */\n    this.value\n\n    // The below are non-standard, they are well-known.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */\n    this.stored\n\n    /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */\n    this.map\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const prop = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (\n        prop in options &&\n        options[prop] !== undefined &&\n        options[prop] !== null\n      ) {\n        // @ts-expect-error: TS doesnt understand basic reality.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]\n      }\n    }\n\n    /** @type {string} */\n    let prop\n\n    // Set non-path related properties.\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) {\n        // @ts-expect-error: fine to set other things.\n        this[prop] = options[prop]\n      }\n    }\n  }\n\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {string | URL} path\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Get the parent path (example: `'~'`).\n   */\n  get dirname() {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined\n  }\n\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if theres no `path` yet.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = path.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */\n  get basename() {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined\n  }\n\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = path.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */\n  get extname() {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined\n  }\n\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if theres no `path` yet.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = path.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? path.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when its a `Buffer`\n   *   (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(encoding) {\n    return (this.value || '').toString(encoding || undefined)\n  }\n\n  /**\n   * Create a warning message associated with the file.\n   *\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(reason, place, origin) {\n    const message = new VFileMessage(reason, place, origin)\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Create an info message associated with the file.\n   *\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = null\n\n    return message\n  }\n\n  /**\n   * Create a fatal error associated with the file.\n   *\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * >  **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Message.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {void}\n *   Nothing.\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(path.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n\n/**\n * Assert `value` is a buffer.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Buffer}\n *   Whether `value` is a Node.js buffer.\n */\nfunction buffer(value) {\n  return bufferLike(value)\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n */\n\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\n/**\n * Message.\n */\nexport class VFileMessage extends Error {\n  /**\n   * Create a message for `reason` at `place` from `origin`.\n   *\n   * When an error is passed in as `reason`, the `stack` is copied.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   *\n   *   >  **Note**: you should use markdown.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns\n   *   Instance of `VFileMessage`.\n   */\n  // To do: next major: expose `undefined` everywhere instead of `null`.\n  constructor(reason, place, origin) {\n    /** @type {[string | null, string | null]} */\n    const parts = [null, null]\n    /** @type {Position} */\n    let position = {\n      // @ts-expect-error: we always follows the structure of `position`.\n      start: {line: null, column: null},\n      // @ts-expect-error: \"\n      end: {line: null, column: null}\n    }\n\n    super()\n\n    if (typeof place === 'string') {\n      origin = place\n      place = undefined\n    }\n\n    if (typeof origin === 'string') {\n      const index = origin.indexOf(':')\n\n      if (index === -1) {\n        parts[1] = origin\n      } else {\n        parts[0] = origin.slice(0, index)\n        parts[1] = origin.slice(index + 1)\n      }\n    }\n\n    if (place) {\n      // Node.\n      if ('type' in place || 'position' in place) {\n        if (place.position) {\n          // To do: next major: deep clone.\n          // @ts-expect-error: looks like a position.\n          position = place.position\n        }\n      }\n      // Position.\n      else if ('start' in place || 'end' in place) {\n        // @ts-expect-error: looks like a position.\n        // To do: next major: deep clone.\n        position = place\n      }\n      // Point.\n      else if ('line' in place || 'column' in place) {\n        // To do: next major: deep clone.\n        position.start = place\n      }\n    }\n\n    // Fields from `Error`.\n    /**\n     * Serialized positional info of error.\n     *\n     * On normal errors, this would be something like `ParseError`, buit in\n     * `VFile` messages we use this space to show where an error happened.\n     */\n    this.name = stringifyPosition(place) || '1:1'\n\n    /**\n     * Reason for message.\n     *\n     * @type {string}\n     */\n    this.message = typeof reason === 'object' ? reason.message : reason\n\n    /**\n     * Stack of message.\n     *\n     * This is used by normal errors to show where something happened in\n     * programming code, irrelevant for `VFile` messages,\n     *\n     * @type {string}\n     */\n    this.stack = ''\n\n    if (typeof reason === 'object' && reason.stack) {\n      this.stack = reason.stack\n    }\n\n    /**\n     * Reason for message.\n     *\n     * >  **Note**: you should use markdown.\n     *\n     * @type {string}\n     */\n    this.reason = this.message\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * State of problem.\n     *\n     * * `true`  marks associated file as no longer processable (error)\n     * * `false`  necessitates a (potential) change (warning)\n     * * `null | undefined`  for things that might not need changing (info)\n     *\n     * @type {boolean | null | undefined}\n     */\n    this.fatal\n\n    /**\n     * Starting line of error.\n     *\n     * @type {number | null}\n     */\n    this.line = position.start.line\n\n    /**\n     * Starting column of error.\n     *\n     * @type {number | null}\n     */\n    this.column = position.start.column\n\n    /**\n     * Full unist position.\n     *\n     * @type {Position | null}\n     */\n    this.position = position\n\n    /**\n     * Namespace of message (example: `'my-package'`).\n     *\n     * @type {string | null}\n     */\n    this.source = parts[0]\n\n    /**\n     * Category of message (example: `'my-rule'`).\n     *\n     * @type {string | null}\n     */\n    this.ruleId = parts[1]\n\n    /**\n     * Path of a file (used throughout the `VFile` ecosystem).\n     *\n     * @type {string | null}\n     */\n    this.file\n\n    // The following fields are well known.\n    // Not standard.\n    // Feel free to add other non-standard fields to your messages.\n\n    /**\n     * Specify the source value thats being reported, which is deemed\n     * incorrect.\n     *\n     * @type {string | null}\n     */\n    this.actual\n\n    /**\n     * Suggest acceptable values that can be used instead of `actual`.\n     *\n     * @type {Array<string> | null}\n     */\n    this.expected\n\n    /**\n     * Link to docs for the message.\n     *\n     * >  **Note**: this must be an absolute URL that can be passed as `x`\n     * > to `new URL(x)`.\n     *\n     * @type {string | null}\n     */\n    this.url\n\n    /**\n     * Long form description of the message (you should use markdown).\n     *\n     * @type {string | null}\n     */\n    this.note\n    /* eslint-enable no-unused-expressions */\n  }\n}\n\nVFileMessage.prototype.file = ''\nVFileMessage.prototype.name = ''\nVFileMessage.prototype.reason = ''\nVFileMessage.prototype.message = ''\nVFileMessage.prototype.stack = ''\nVFileMessage.prototype.fatal = null\nVFileMessage.prototype.column = null\nVFileMessage.prototype.line = null\nVFileMessage.prototype.source = null\nVFileMessage.prototype.ruleId = null\nVFileMessage.prototype.position = null\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","export {default as path} from 'path'\n","export {default as proc} from 'process'\n","/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */\n\n/**\n * Check if `fileUrlOrPath` looks like a URL.\n *\n * @param {unknown} fileUrlOrPath\n *   File path or URL.\n * @returns {fileUrlOrPath is URL}\n *   Whether its a URL.\n */\n// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nexport function isUrl(fileUrlOrPath) {\n  return (\n    fileUrlOrPath !== null &&\n    typeof fileUrlOrPath === 'object' &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.href &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.origin\n  )\n}\n","export {fileURLToPath as urlToPath} from 'url'\nexport {isUrl} from './minurl.shared.js'\n","import remarkParse from './lib/index.js'\n\nexport default remarkParse\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').Options} Options\n */\n\nimport {fromMarkdown} from 'mdast-util-from-markdown'\n\n/** @type {import('unified').Plugin<[Options?] | void[], string, Root>} */\nexport default function remarkParse(options) {\n  /** @type {import('unified').ParserFunction<Root>} */\n  const parser = (doc) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return fromMarkdown(\n      doc,\n      Object.assign({}, settings, options, {\n        // Note: these options are not in the readme.\n        // The goal is for them to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions: this.data('micromarkExtensions') || [],\n        mdastExtensions: this.data('fromMarkdownExtensions') || []\n      })\n    )\n  }\n\n  Object.assign(this, {Parser: parser})\n}\n","/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isnt closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n\n// To do: micromark: create a registry of tokens?\n// To do: next major: dont return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\n\nimport {toString} from 'mdast-util-to-string'\nimport {parse} from 'micromark/lib/parse.js'\nimport {preprocess} from 'micromark/lib/preprocess.js'\nimport {postprocess} from 'micromark/lib/postprocess.js'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */\nexport const fromMarkdown =\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */\n\n  /**\n   * @param {Value} value\n   * @param {Encoding | Options | null | undefined} [encoding]\n   * @param {Options | null | undefined} [options]\n   * @returns {Root}\n   */\n  function (value, encoding, options) {\n    if (typeof encoding !== 'string') {\n      options = encoding\n      encoding = undefined\n    }\n    return compiler(options)(\n      postprocess(\n        // @ts-expect-error: micromark types need to accept `null`.\n        parse(options).document().write(preprocess()(value, encoding, true))\n      )\n    )\n  }\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }\n  configure(config, (options || {}).mdastExtensions || [])\n\n  /** @type {CompileData} */\n  const data = {}\n  return compile\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    }\n    /** @type {Array<number>} */\n    const listStack = []\n    let index = -1\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n\n    // Call transforms.\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n    return tree\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token | undefined} */\n    let listItem\n    /** @type {number | undefined} */\n    let lineIndex\n    /** @type {number | undefined} */\n    let firstBlankLineIndex\n    /** @type {boolean | undefined} */\n    let atMarker\n    while (++index <= length) {\n      const event = events[index]\n      if (\n        event[1].type === 'listUnordered' ||\n        event[1].type === 'listOrdered' ||\n        event[1].type === 'blockQuote'\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n        atMarker = undefined\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === 'linePrefix' ||\n        event[1].type === 'listItemValue' ||\n        event[1].type === 'listItemMarker' ||\n        event[1].type === 'listItemPrefix' ||\n        event[1].type === 'listItemPrefixWhitespace'\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            // @ts-expect-error Patched.\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            // @ts-expect-error Patched\n            _spread: false,\n            start: Object.assign({}, event[1].start)\n          }\n          // @ts-expect-error: `listItem` is most definitely defined, TS...\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n\n    // @ts-expect-error Patched.\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */\n  function setData(key, value) {\n    data[key] = value\n  }\n\n  /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */\n  function getData(key) {\n    return data[key]\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {void}\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n\n  /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler])\n    // @ts-expect-error: `end` will be patched later.\n    node.position = {\n      start: point(token.start)\n    }\n    return node\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): its not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n    node.position.end = point(token.end)\n    return node\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor = this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      setData('expectingFirstListItemValue')\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    setData('flowCodeInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1]\n    let tail = node.children[node.children.length - 1]\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      // @ts-expect-error: well add `end` later.\n      tail.position = {\n        start: point(token.start)\n      }\n      // @ts-expect-error: Assume `parent` accepts `text`.\n      node.children.push(tail)\n    }\n    this.stack.push(tail)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n    // If were at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      setData('atHardBreak')\n      return\n    }\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token)\n    const ancestor = this.stack[this.stack.length - 2]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string)\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // Assume a reference.\n    setData('inReference', true)\n    if (node.type === 'link') {\n      /** @type {Array<StaticPhrasingContent>} */\n      // @ts-expect-error: Assume static phrasing content.\n      const children = fragment.children\n      node.children = children\n    } else {\n      node.alt = value\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    setData('inReference')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = getData('characterReferenceType')\n    /** @type {string} */\n    let value\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      setData('characterReferenceType')\n    } else {\n      const result = decodeNamedCharacterReference(data)\n      value = result\n    }\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    }\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n\n  /** @returns {HTML} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */\nfunction configure(combined, extensions) {\n  let index = -1\n  while (++index < extensions.length) {\n    const value = extensions[index]\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      if (key === 'canContainEols') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'transforms') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'enter' || key === 'exit') {\n        const right = extension[key]\n        if (right) {\n          Object.assign(combined[key], right)\n        }\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({\n          start: left.start,\n          end: left.end\n        }) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is still open'\n    )\n  }\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the nodes plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').FullNormalizedExtension} FullNormalizedExtension\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n * @typedef {import('micromark-util-types').Create} Create\n */\nimport {combineExtensions} from 'micromark-util-combine-extensions'\nimport {content} from './initialize/content.js'\nimport {document} from './initialize/document.js'\nimport {flow} from './initialize/flow.js'\nimport {text, string} from './initialize/text.js'\nimport {createTokenizer} from './create-tokenizer.js'\nimport * as defaultConstructs from './constructs.js'\n/**\n * @param {ParseOptions} [options]\n * @returns {ParseContext}\n */\n\nexport function parse(options = {}) {\n  /** @type {FullNormalizedExtension} */\n  // @ts-expect-error `defaultConstructs` is full, so the result will be too.\n  const constructs = combineExtensions(\n    // @ts-expect-error Same as above.\n    [defaultConstructs].concat(options.extensions || [])\n  )\n  /** @type {ParseContext} */\n\n  const parser = {\n    defined: [],\n    lazy: {},\n    constructs,\n    content: create(content),\n    document: create(document),\n    flow: create(flow),\n    string: create(string),\n    text: create(text)\n  }\n  return parser\n  /**\n   * @param {InitialConstruct} initial\n   */\n\n  function create(initial) {\n    return creator\n    /** @type {Create} */\n\n    function creator(from) {\n      return createTokenizer(parser, initial, from)\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\nimport {splice} from 'micromark-util-chunked'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * Combine several syntax extensions into one.\n *\n * @param {Extension[]} extensions List of syntax extensions.\n * @returns {NormalizedExtension} A single combined extension.\n */\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {}\n  let index = -1\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index])\n  }\n\n  return all\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all Extension to merge into.\n * @param {Extension} extension Extension to merge.\n * @returns {void}\n */\nfunction syntaxExtension(all, extension) {\n  /** @type {string} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {string} */\n    let code\n\n    for (code in right) {\n      if (!hasOwnProperty.call(left, code)) left[code] = []\n      const value = right[code]\n      constructs(\n        // @ts-expect-error Looks like a list.\n        left[code],\n        Array.isArray(value) ? value : value ? [value] : []\n      )\n    }\n  }\n}\n\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {unknown[]} existing\n * @param {unknown[]} list\n * @returns {void}\n */\nfunction constructs(existing, list) {\n  let index = -1\n  /** @type {unknown[]} */\n  const before = []\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  splice(existing, 0, 0, before)\n}\n\n/**\n * Combine several HTML extensions into one.\n *\n * @param {HtmlExtension[]} htmlExtensions List of HTML extensions.\n * @returns {HtmlExtension} A single combined extension.\n */\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {}\n  let index = -1\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index])\n  }\n\n  return handlers\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all Extension to merge into.\n * @param {HtmlExtension} extension Extension to merge.\n * @returns {void}\n */\nfunction htmlExtension(all, extension) {\n  /** @type {string} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {string} */\n    let type\n\n    if (right) {\n      for (type in right) {\n        left[type] = right[type]\n      }\n    }\n  }\n}\n","/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {number} start\n * @param {number} remove\n * @param {T[]} items\n * @returns {void}\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {unknown[]} */\n\n  let parameters // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n\n  remove = remove > 0 ? remove : 0 // No need to chunk the items if theres only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove) // @ts-expect-error Hush, its fine.\n    ;[].splice.apply(list, parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) [].splice.apply(list, [start, remove]) // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0) // @ts-expect-error Hush, its fine.\n      ;[].splice.apply(list, parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n * @param {T[]} list\n * @param {T[]} items\n * @returns {T[]}\n */\n\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n\n  return items\n}\n","/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {InitialConstruct} */\nexport const content = {\n  tokenize: initializeContent\n}\n/** @type {Initializer} */\n\nfunction initializeContent(effects) {\n  const contentStart = effects.attempt(\n    this.parser.constructs.contentInitial,\n    afterContentStartConstruct,\n    paragraphInitial\n  )\n  /** @type {Token} */\n\n  let previous\n  return contentStart\n  /** @type {State} */\n\n  function afterContentStartConstruct(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, contentStart, 'linePrefix')\n  }\n  /** @type {State} */\n\n  function paragraphInitial(code) {\n    effects.enter('paragraph')\n    return lineStart(code)\n  }\n  /** @type {State} */\n\n  function lineStart(code) {\n    const token = effects.enter('chunkText', {\n      contentType: 'text',\n      previous\n    })\n\n    if (previous) {\n      previous.next = token\n    }\n\n    previous = token\n    return data(code)\n  }\n  /** @type {State} */\n\n  function data(code) {\n    if (code === null) {\n      effects.exit('chunkText')\n      effects.exit('paragraph')\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      effects.exit('chunkText')\n      return lineStart\n    } // Data.\n\n    effects.consume(code)\n    return data\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownSpace} from 'micromark-util-character'\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\n\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexport const asciiDigit = regexCheck(/\\d/)\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\nexport const unicodeWhitespace = regexCheck(/\\s/)\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nfunction regexCheck(regex) {\n  return check\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\nexport const unicodePunctuationRegex =\n  /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Point} Point\n */\n\n/**\n * @typedef {Record<string, unknown>} StackState\n * @typedef {[Construct, StackState]} StackItem\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n/** @type {InitialConstruct} */\n\nexport const document = {\n  tokenize: initializeDocument\n}\n/** @type {Construct} */\n\nconst containerConstruct = {\n  tokenize: tokenizeContainer\n}\n/** @type {Initializer} */\n\nfunction initializeDocument(effects) {\n  const self = this\n  /** @type {Array<StackItem>} */\n\n  const stack = []\n  let continued = 0\n  /** @type {TokenizeContext|undefined} */\n\n  let childFlow\n  /** @type {Token|undefined} */\n\n  let childToken\n  /** @type {number} */\n\n  let lineStartOffset\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      const item = stack[continued]\n      self.containerState = item[1]\n      return effects.attempt(\n        item[0].continuation,\n        documentContinue,\n        checkNewContainers\n      )(code)\n    } // Done.\n\n    return checkNewContainers(code)\n  }\n  /** @type {State} */\n\n  function documentContinue(code) {\n    continued++ // Note: this field is called `_closeFlow` but it also closes containers.\n    // Perhaps a good idea to rename it but its already used in the wild by\n    // extensions.\n\n    if (self.containerState._closeFlow) {\n      self.containerState._closeFlow = undefined\n\n      if (childFlow) {\n        closeFlow()\n      } // Note: this algorithm for moving events around is similar to the\n      // algorithm when dealing with lazy lines in `writeToChild`.\n\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {Point|undefined} */\n\n      let point // Find the flow chunk.\n\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          point = self.events[indexBeforeFlow][1].end\n          break\n        }\n      }\n\n      exitContainers(continued) // Fix positions.\n\n      let index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      } // Inject the exits earlier (theyre still also at the end).\n\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      ) // Discard the duplicate exits.\n\n      self.events.length = index\n      return checkNewContainers(code)\n    }\n\n    return start(code)\n  }\n  /** @type {State} */\n\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether theres a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code)\n      } // If we have concrete content, such as block HTML or fenced code,\n      // we cant have containers pierce into them, so we can immediately\n      // start.\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code)\n      } // If we do have flow, it could still be a blank line,\n      // but wed be interrupting it w/ a new container if theres a current\n      // construct.\n\n      self.interrupt = Boolean(\n        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack\n      )\n    } // Check if there is a new container.\n\n    self.containerState = {}\n    return effects.check(\n      containerConstruct,\n      thereIsANewContainer,\n      thereIsNoNewContainer\n    )(code)\n  }\n  /** @type {State} */\n\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow()\n    exitContainers(continued)\n    return documentContinued(code)\n  }\n  /** @type {State} */\n\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length\n    lineStartOffset = self.now().offset\n    return flowStart(code)\n  }\n  /** @type {State} */\n\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n  /** @type {State} */\n\n  function containerContinue(code) {\n    continued++\n    stack.push([self.currentConstruct, self.containerState]) // Try another.\n\n    return documentContinued(code)\n  }\n  /** @type {State} */\n\n  function flowStart(code) {\n    if (code === null) {\n      if (childFlow) closeFlow()\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    })\n    return flowContinue(code)\n  }\n  /** @type {State} */\n\n  function flowContinue(code) {\n    if (code === null) {\n      writeToChild(effects.exit('chunkFlow'), true)\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      writeToChild(effects.exit('chunkFlow')) // Get ready for the next line.\n\n      continued = 0\n      self.interrupt = undefined\n      return start\n    }\n\n    effects.consume(code)\n    return flowContinue\n  }\n  /**\n   * @param {Token} token\n   * @param {boolean} [eof]\n   * @returns {void}\n   */\n\n  function writeToChild(token, eof) {\n    const stream = self.sliceStream(token)\n    if (eof) stream.push(null)\n    token.previous = childToken\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.defineSkip(token.start)\n    childFlow.write(stream) // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line cant unmake it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which unmakes the first line\n    // and turns the whole into one content block.\n    //\n    // Weve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n\n    if (self.parser.lazy[token.start.line]) {\n      let index = childFlow.events.length\n\n      while (index--) {\n        if (\n          // The token starts before the line ending\n          childFlow.events[index][1].start.offset < lineStartOffset && // and either is not ended yet\n          (!childFlow.events[index][1].end || // or ends after it.\n            childFlow.events[index][1].end.offset > lineStartOffset)\n        ) {\n          // Exit: theres still something open, which means its a lazy line\n          // part of something.\n          return\n        }\n      } // Note: this algorithm for moving events around is similar to the\n      // algorithm when closing flow in `documentContinue`.\n\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {boolean|undefined} */\n\n      let seen\n      /** @type {Point|undefined} */\n\n      let point // Find the previous chunk (the one before the lazy line).\n\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end\n            break\n          }\n\n          seen = true\n        }\n      }\n\n      exitContainers(continued) // Fix positions.\n\n      index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      } // Inject the exits earlier (theyre still also at the end).\n\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      ) // Discard the duplicate exits.\n\n      self.events.length = index\n    }\n  }\n  /**\n   * @param {number} size\n   * @returns {void}\n   */\n\n  function exitContainers(size) {\n    let index = stack.length // Exit open containers.\n\n    while (index-- > size) {\n      const entry = stack[index]\n      self.containerState = entry[1]\n      entry[0].exit.call(self, effects)\n    }\n\n    stack.length = size\n  }\n\n  function closeFlow() {\n    childFlow.write([null])\n    childToken = undefined\n    childFlow = undefined\n    self.containerState._closeFlow = undefined\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {blankLine, content} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {InitialConstruct} */\nexport const flow = {\n  tokenize: initializeFlow\n}\n/** @type {Initializer} */\n\nfunction initializeFlow(effects) {\n  const self = this\n  const initial = effects.attempt(\n    // Try to parse a blank line.\n    blankLine,\n    atBlankEnding, // Try to parse initial flow (essentially, only code).\n    effects.attempt(\n      this.parser.constructs.flowInitial,\n      afterConstruct,\n      factorySpace(\n        effects,\n        effects.attempt(\n          this.parser.constructs.flow,\n          afterConstruct,\n          effects.attempt(content, afterConstruct)\n        ),\n        'linePrefix'\n      )\n    )\n  )\n  return initial\n  /** @type {State} */\n\n  function atBlankEnding(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEndingBlank')\n    effects.consume(code)\n    effects.exit('lineEndingBlank')\n    self.currentConstruct = undefined\n    return initial\n  }\n  /** @type {State} */\n\n  function afterConstruct(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    self.currentConstruct = undefined\n    return initial\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const blankLine = {\n  tokenize: tokenizeBlankLine,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return factorySpace(effects, afterWhitespace, 'linePrefix')\n  /** @type {State} */\n\n  function afterWhitespace(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {subtokenize} from 'micromark-util-subtokenize'\n\n/**\n * No name because it must not be turned off.\n * @type {Construct}\n */\nexport const content = {\n  tokenize: tokenizeContent,\n  resolve: resolveContent\n}\n/** @type {Construct} */\n\nconst continuationConstruct = {\n  tokenize: tokenizeContinuation,\n  partial: true\n}\n/**\n * Content is transparent: its parsed right now. That way, definitions are also\n * parsed right now: before text in paragraphs (specifically, media) are parsed.\n *\n * @type {Resolver}\n */\n\nfunction resolveContent(events) {\n  subtokenize(events)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeContent(effects, ok) {\n  /** @type {Token} */\n  let previous\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('content')\n    previous = effects.enter('chunkContent', {\n      contentType: 'content'\n    })\n    return data(code)\n  }\n  /** @type {State} */\n\n  function data(code) {\n    if (code === null) {\n      return contentEnd(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.check(\n        continuationConstruct,\n        contentContinue,\n        contentEnd\n      )(code)\n    } // Data.\n\n    effects.consume(code)\n    return data\n  }\n  /** @type {State} */\n\n  function contentEnd(code) {\n    effects.exit('chunkContent')\n    effects.exit('content')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    effects.consume(code)\n    effects.exit('chunkContent')\n    previous.next = effects.enter('chunkContent', {\n      contentType: 'content',\n      previous\n    })\n    previous = previous.next\n    return data\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeContinuation(effects, ok, nok) {\n  const self = this\n  return startLookahead\n  /** @type {State} */\n\n  function startLookahead(code) {\n    effects.exit('chunkContent')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, prefixed, 'linePrefix')\n  }\n  /** @type {State} */\n\n  function prefixed(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    const tail = self.events[self.events.length - 1]\n\n    if (\n      !self.parser.constructs.disable.null.includes('codeIndented') &&\n      tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n    ) {\n      return ok(code)\n    }\n\n    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Event} Event\n */\nimport {splice} from 'micromark-util-chunked'\n\n/**\n * Tokenize subcontent.\n *\n * @param {Event[]} events\n * @returns {boolean}\n */\nexport function subtokenize(events) {\n  /** @type {Record<string, number>} */\n  const jumps = {}\n  let index = -1\n  /** @type {Event} */\n\n  let event\n  /** @type {number|undefined} */\n\n  let lineIndex\n  /** @type {number} */\n\n  let otherIndex\n  /** @type {Event} */\n\n  let otherEvent\n  /** @type {Event[]} */\n\n  let parameters\n  /** @type {Event[]} */\n\n  let subevents\n  /** @type {boolean|undefined} */\n\n  let more\n\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index]\n    }\n\n    event = events[index] // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n\n    if (\n      index &&\n      event[1].type === 'chunkFlow' &&\n      events[index - 1][1].type === 'listItemPrefix'\n    ) {\n      subevents = event[1]._tokenizer.events\n      otherIndex = 0\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'lineEndingBlank'\n      ) {\n        otherIndex += 2\n      }\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'content'\n      ) {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === 'content') {\n            break\n          }\n\n          if (subevents[otherIndex][1].type === 'chunkText') {\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true\n            otherIndex++\n          }\n        }\n      }\n    } // Enter.\n\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        Object.assign(jumps, subcontent(events, index))\n        index = jumps[index]\n        more = true\n      }\n    } // Exit.\n    else if (event[1]._container) {\n      otherIndex = index\n      lineIndex = undefined\n\n      while (otherIndex--) {\n        otherEvent = events[otherIndex]\n\n        if (\n          otherEvent[1].type === 'lineEnding' ||\n          otherEvent[1].type === 'lineEndingBlank'\n        ) {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events[lineIndex][1].type = 'lineEndingBlank'\n            }\n\n            otherEvent[1].type = 'lineEnding'\n            lineIndex = otherIndex\n          }\n        } else {\n          break\n        }\n      }\n\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = Object.assign({}, events[lineIndex][1].start) // Switch container exit w/ line endings.\n\n        parameters = events.slice(lineIndex, index)\n        parameters.unshift(event)\n        splice(events, lineIndex, index - lineIndex + 1, parameters)\n      }\n    }\n  }\n\n  return !more\n}\n/**\n * Tokenize embedded tokens.\n *\n * @param {Event[]} events\n * @param {number} eventIndex\n * @returns {Record<string, number>}\n */\n\nfunction subcontent(events, eventIndex) {\n  const token = events[eventIndex][1]\n  const context = events[eventIndex][2]\n  let startPosition = eventIndex - 1\n  /** @type {number[]} */\n\n  const startPositions = []\n  const tokenizer =\n    token._tokenizer || context.parser[token.contentType](token.start)\n  const childEvents = tokenizer.events\n  /** @type {[number, number][]} */\n\n  const jumps = []\n  /** @type {Record<string, number>} */\n\n  const gaps = {}\n  /** @type {Chunk[]} */\n\n  let stream\n  /** @type {Token|undefined} */\n\n  let previous\n  let index = -1\n  /** @type {Token|undefined} */\n\n  let current = token\n  let adjust = 0\n  let start = 0\n  const breaks = [start] // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n\n  while (current) {\n    // Find the position of the event for this token.\n    while (events[++startPosition][1] !== current) {\n      // Empty.\n    }\n\n    startPositions.push(startPosition)\n\n    if (!current._tokenizer) {\n      stream = context.sliceStream(current)\n\n      if (!current.next) {\n        stream.push(null)\n      }\n\n      if (previous) {\n        tokenizer.defineSkip(current.start)\n      }\n\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true\n      }\n\n      tokenizer.write(stream)\n\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined\n      }\n    } // Unravel the next token.\n\n    previous = current\n    current = current.next\n  } // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n\n  current = token\n\n  while (++index < childEvents.length) {\n    if (\n      // Find a void token that includes a break.\n      childEvents[index][0] === 'exit' &&\n      childEvents[index - 1][0] === 'enter' &&\n      childEvents[index][1].type === childEvents[index - 1][1].type &&\n      childEvents[index][1].start.line !== childEvents[index][1].end.line\n    ) {\n      start = index + 1\n      breaks.push(start) // Help GC.\n\n      current._tokenizer = undefined\n      current.previous = undefined\n      current = current.next\n    }\n  } // Help GC.\n\n  tokenizer.events = [] // If theres one more token (which is the cases for lines that end in an\n  // EOF), thats perfect: the last point we found starts it.\n  // If there isnt then make sure any remaining content is added to it.\n\n  if (current) {\n    // Help GC.\n    current._tokenizer = undefined\n    current.previous = undefined\n  } else {\n    breaks.pop()\n  } // Now splice the events from the subtokenizer into the current events,\n  // moving back to front so that splice indices arent affected.\n\n  index = breaks.length\n\n  while (index--) {\n    const slice = childEvents.slice(breaks[index], breaks[index + 1])\n    const start = startPositions.pop()\n    jumps.unshift([start, start + slice.length - 1])\n    splice(events, start, 2, slice)\n  }\n\n  index = -1\n\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]\n    adjust += jumps[index][1] - jumps[index][0] - 1\n  }\n\n  return gaps\n}\n","/**\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nexport const resolver = {\n  resolveAll: createResolver()\n}\nexport const string = initializeFactory('string')\nexport const text = initializeFactory('text')\n/**\n * @param {'string'|'text'} field\n * @returns {InitialConstruct}\n */\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    )\n  }\n  /** @type {Initializer} */\n\n  function initializeText(effects) {\n    const self = this\n    const constructs = this.parser.constructs[field]\n    const text = effects.attempt(constructs, start, notText)\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n    /** @type {State} */\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code)\n        return\n      }\n\n      effects.enter('data')\n      effects.consume(code)\n      return data\n    }\n    /** @type {State} */\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data')\n        return text(code)\n      } // Data.\n\n      effects.consume(code)\n      return data\n    }\n    /**\n     * @param {Code} code\n     * @returns {boolean}\n     */\n\n    function atBreak(code) {\n      if (code === null) {\n        return true\n      }\n\n      const list = constructs[code]\n      let index = -1\n\n      if (list) {\n        while (++index < list.length) {\n          const item = list[index]\n\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true\n          }\n        }\n      }\n\n      return false\n    }\n  }\n}\n/**\n * @param {Resolver} [extraResolver]\n * @returns {Resolver}\n */\n\nfunction createResolver(extraResolver) {\n  return resolveAllText\n  /** @type {Resolver} */\n\n  function resolveAllText(events, context) {\n    let index = -1\n    /** @type {number|undefined} */\n\n    let enter // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Dont do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n\n        enter = undefined\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events\n  }\n}\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we cant hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\n\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0 // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === 'lineEnding') &&\n      events[eventIndex - 1][1].type === 'data'\n    ) {\n      const data = events[eventIndex - 1][1]\n      const chunks = context.sliceStream(data)\n      let index = chunks.length\n      let bufferIndex = -1\n      let size = 0\n      /** @type {boolean|undefined} */\n\n      let tabs\n\n      while (index--) {\n        const chunk = chunks[index]\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++\n            bufferIndex--\n          }\n\n          if (bufferIndex) break\n          bufferIndex = -1\n        } // Number\n        else if (chunk === -2) {\n          tabs = true\n          size++\n        } else if (chunk === -1) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n\n      if (size) {\n        const token = {\n          type:\n            eventIndex === events.length || tabs || size < 2\n              ? 'lineSuffix'\n              : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex\n          },\n          end: Object.assign({}, data.end)\n        }\n        data.end = Object.assign({}, token.start)\n\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n\n      eventIndex++\n    }\n  }\n\n  return events\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n */\n\n/**\n * @typedef Info\n * @property {() => void} restore\n * @property {number} from\n *\n * @callback ReturnHandle\n *   Handle a successful run.\n * @param {Construct} construct\n * @param {Info} info\n * @returns {void}\n */\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/**\n * Create a tokenizer.\n * Tokenizers deal with one type of data (e.g., containers, flow, text).\n * The parser is the object dealing with it all.\n * `initialize` works like other constructs, except that only its `tokenize`\n * function is used, in which case it doesnt receive an `ok` or `nok`.\n * `from` can be given to set the point before the first character, although\n * when further lines are indented, they must be set with `defineSkip`.\n *\n * @param {ParseContext} parser\n * @param {InitialConstruct} initialize\n * @param {Omit<Point, '_index'|'_bufferIndex'>} [from]\n * @returns {TokenizeContext}\n */\nexport function createTokenizer(parser, initialize, from) {\n  /** @type {Point} */\n  let point = Object.assign(\n    from\n      ? Object.assign({}, from)\n      : {\n          line: 1,\n          column: 1,\n          offset: 0\n        },\n    {\n      _index: 0,\n      _bufferIndex: -1\n    }\n  )\n  /** @type {Record<string, number>} */\n\n  const columnStart = {}\n  /** @type {Array<Construct>} */\n\n  const resolveAllConstructs = []\n  /** @type {Array<Chunk>} */\n\n  let chunks = []\n  /** @type {Array<Token>} */\n\n  let stack = []\n  /** @type {boolean|undefined} */\n\n  let consumed = true\n  /**\n   * Tools used for tokenizing.\n   *\n   * @type {Effects}\n   */\n\n  const effects = {\n    consume,\n    enter,\n    exit,\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    })\n  }\n  /**\n   * State and tools for resolving and serializing.\n   *\n   * @type {TokenizeContext}\n   */\n\n  const context = {\n    previous: null,\n    code: null,\n    containerState: {},\n    events: [],\n    parser,\n    sliceStream,\n    sliceSerialize,\n    now,\n    defineSkip,\n    write\n  }\n  /**\n   * The state function.\n   *\n   * @type {State|void}\n   */\n\n  let state = initialize.tokenize.call(context, effects)\n  /**\n   * Track which character we expect to be consumed, to catch bugs.\n   *\n   * @type {Code}\n   */\n\n  let expectedCode\n\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize)\n  }\n\n  return context\n  /** @type {TokenizeContext['write']} */\n\n  function write(slice) {\n    chunks = push(chunks, slice)\n    main() // Exit if were not done, resolve might change stuff.\n\n    if (chunks[chunks.length - 1] !== null) {\n      return []\n    }\n\n    addResult(initialize, 0) // Otherwise, resolve, and exit.\n\n    context.events = resolveAll(resolveAllConstructs, context.events, context)\n    return context.events\n  } //\n  // Tools.\n  //\n\n  /** @type {TokenizeContext['sliceSerialize']} */\n\n  function sliceSerialize(token, expandTabs) {\n    return serializeChunks(sliceStream(token), expandTabs)\n  }\n  /** @type {TokenizeContext['sliceStream']} */\n\n  function sliceStream(token) {\n    return sliceChunks(chunks, token)\n  }\n  /** @type {TokenizeContext['now']} */\n\n  function now() {\n    return Object.assign({}, point)\n  }\n  /** @type {TokenizeContext['defineSkip']} */\n\n  function defineSkip(value) {\n    columnStart[value.line] = value.column\n    accountForPotentialSkip()\n  } //\n  // State management.\n  //\n\n  /**\n   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n   * `consume`).\n   * Here is where we walk through the chunks, which either include strings of\n   * several characters, or numerical character codes.\n   * The reason to do this in a loop instead of a call is so the stack can\n   * drain.\n   *\n   * @returns {void}\n   */\n\n  function main() {\n    /** @type {number} */\n    let chunkIndex\n\n    while (point._index < chunks.length) {\n      const chunk = chunks[point._index] // If were in a buffer chunk, loop through it.\n\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index\n\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0\n        }\n\n        while (\n          point._index === chunkIndex &&\n          point._bufferIndex < chunk.length\n        ) {\n          go(chunk.charCodeAt(point._bufferIndex))\n        }\n      } else {\n        go(chunk)\n      }\n    }\n  }\n  /**\n   * Deal with one code.\n   *\n   * @param {Code} code\n   * @returns {void}\n   */\n\n  function go(code) {\n    consumed = undefined\n    expectedCode = code\n    state = state(code)\n  }\n  /** @type {Effects['consume']} */\n\n  function consume(code) {\n    if (markdownLineEnding(code)) {\n      point.line++\n      point.column = 1\n      point.offset += code === -3 ? 2 : 1\n      accountForPotentialSkip()\n    } else if (code !== -1) {\n      point.column++\n      point.offset++\n    } // Not in a string chunk.\n\n    if (point._bufferIndex < 0) {\n      point._index++\n    } else {\n      point._bufferIndex++ // At end of string chunk.\n      // @ts-expect-error Points w/ non-negative `_bufferIndex` reference\n      // strings.\n\n      if (point._bufferIndex === chunks[point._index].length) {\n        point._bufferIndex = -1\n        point._index++\n      }\n    } // Expose the previous character.\n\n    context.previous = code // Mark as consumed.\n\n    consumed = true\n  }\n  /** @type {Effects['enter']} */\n\n  function enter(type, fields) {\n    /** @type {Token} */\n    // @ts-expect-error Patch instead of assign required fields to help GC.\n    const token = fields || {}\n    token.type = type\n    token.start = now()\n    context.events.push(['enter', token, context])\n    stack.push(token)\n    return token\n  }\n  /** @type {Effects['exit']} */\n\n  function exit(type) {\n    const token = stack.pop()\n    token.end = now()\n    context.events.push(['exit', token, context])\n    return token\n  }\n  /**\n   * Use results.\n   *\n   * @type {ReturnHandle}\n   */\n\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from)\n  }\n  /**\n   * Discard results.\n   *\n   * @type {ReturnHandle}\n   */\n\n  function onsuccessfulcheck(_, info) {\n    info.restore()\n  }\n  /**\n   * Factory to attempt/check/interrupt.\n   *\n   * @param {ReturnHandle} onreturn\n   * @param {Record<string, unknown>} [fields]\n   */\n\n  function constructFactory(onreturn, fields) {\n    return hook\n    /**\n     * Handle either an object mapping codes to constructs, a list of\n     * constructs, or a single construct.\n     *\n     * @param {Construct|Array<Construct>|ConstructRecord} constructs\n     * @param {State} returnState\n     * @param {State} [bogusState]\n     * @returns {State}\n     */\n\n    function hook(constructs, returnState, bogusState) {\n      /** @type {Array<Construct>} */\n      let listOfConstructs\n      /** @type {number} */\n\n      let constructIndex\n      /** @type {Construct} */\n\n      let currentConstruct\n      /** @type {Info} */\n\n      let info\n      return Array.isArray(constructs)\n        ? /* c8 ignore next 1 */\n          handleListOfConstructs(constructs)\n        : 'tokenize' in constructs // @ts-expect-error Looks like a construct.\n        ? handleListOfConstructs([constructs])\n        : handleMapOfConstructs(constructs)\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ConstructRecord} map\n       * @returns {State}\n       */\n\n      function handleMapOfConstructs(map) {\n        return start\n        /** @type {State} */\n\n        function start(code) {\n          const def = code !== null && map[code]\n          const all = code !== null && map.null\n          const list = [\n            // To do: add more extension tests.\n\n            /* c8 ignore next 2 */\n            ...(Array.isArray(def) ? def : def ? [def] : []),\n            ...(Array.isArray(all) ? all : all ? [all] : [])\n          ]\n          return handleListOfConstructs(list)(code)\n        }\n      }\n      /**\n       * Handle a list of construct.\n       *\n       * @param {Array<Construct>} list\n       * @returns {State}\n       */\n\n      function handleListOfConstructs(list) {\n        listOfConstructs = list\n        constructIndex = 0\n\n        if (list.length === 0) {\n          return bogusState\n        }\n\n        return handleConstruct(list[constructIndex])\n      }\n      /**\n       * Handle a single construct.\n       *\n       * @param {Construct} construct\n       * @returns {State}\n       */\n\n      function handleConstruct(construct) {\n        return start\n        /** @type {State} */\n\n        function start(code) {\n          // To do: not needed to store if there is no bogus state, probably?\n          // Currently doesnt work because `inspect` in document does a check\n          // w/o a bogus, which doesnt make sense. But it does seem to help perf\n          // by not storing.\n          info = store()\n          currentConstruct = construct\n\n          if (!construct.partial) {\n            context.currentConstruct = construct\n          }\n\n          if (\n            construct.name &&\n            context.parser.constructs.disable.null.includes(construct.name)\n          ) {\n            return nok(code)\n          }\n\n          return construct.tokenize.call(\n            // If we do have fields, create an object w/ `context` as its\n            // prototype.\n            // This allows a live binding, which is needed for `interrupt`.\n            fields ? Object.assign(Object.create(context), fields) : context,\n            effects,\n            ok,\n            nok\n          )(code)\n        }\n      }\n      /** @type {State} */\n\n      function ok(code) {\n        consumed = true\n        onreturn(currentConstruct, info)\n        return returnState\n      }\n      /** @type {State} */\n\n      function nok(code) {\n        consumed = true\n        info.restore()\n\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex])\n        }\n\n        return bogusState\n      }\n    }\n  }\n  /**\n   * @param {Construct} construct\n   * @param {number} from\n   * @returns {void}\n   */\n\n  function addResult(construct, from) {\n    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {\n      resolveAllConstructs.push(construct)\n    }\n\n    if (construct.resolve) {\n      splice(\n        context.events,\n        from,\n        context.events.length - from,\n        construct.resolve(context.events.slice(from), context)\n      )\n    }\n\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context)\n    }\n  }\n  /**\n   * Store state.\n   *\n   * @returns {Info}\n   */\n\n  function store() {\n    const startPoint = now()\n    const startPrevious = context.previous\n    const startCurrentConstruct = context.currentConstruct\n    const startEventsIndex = context.events.length\n    const startStack = Array.from(stack)\n    return {\n      restore,\n      from: startEventsIndex\n    }\n    /**\n     * Restore state.\n     *\n     * @returns {void}\n     */\n\n    function restore() {\n      point = startPoint\n      context.previous = startPrevious\n      context.currentConstruct = startCurrentConstruct\n      context.events.length = startEventsIndex\n      stack = startStack\n      accountForPotentialSkip()\n    }\n  }\n  /**\n   * Move the current point a bit forward in the line when its on a column\n   * skip.\n   *\n   * @returns {void}\n   */\n\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line]\n      point.offset += columnStart[point.line] - 1\n    }\n  }\n}\n/**\n * Get the chunks from a slice of chunks in the range of a token.\n *\n * @param {Array<Chunk>} chunks\n * @param {Pick<Token, 'start'|'end'>} token\n * @returns {Array<Chunk>}\n */\n\nfunction sliceChunks(chunks, token) {\n  const startIndex = token.start._index\n  const startBufferIndex = token.start._bufferIndex\n  const endIndex = token.end._index\n  const endBufferIndex = token.end._bufferIndex\n  /** @type {Array<Chunk>} */\n\n  let view\n\n  if (startIndex === endIndex) {\n    // @ts-expect-error `_bufferIndex` is used on string chunks.\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]\n  } else {\n    view = chunks.slice(startIndex, endIndex)\n\n    if (startBufferIndex > -1) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view[0] = view[0].slice(startBufferIndex)\n    }\n\n    if (endBufferIndex > 0) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view.push(chunks[endIndex].slice(0, endBufferIndex))\n    }\n  }\n\n  return view\n}\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @param {boolean} [expandTabs=false]\n * @returns {string}\n */\n\nfunction serializeChunks(chunks, expandTabs) {\n  let index = -1\n  /** @type {Array<string>} */\n\n  const result = []\n  /** @type {boolean|undefined} */\n\n  let atTab\n\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n\n    let value\n\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case -5: {\n          value = '\\r'\n          break\n        }\n\n        case -4: {\n          value = '\\n'\n          break\n        }\n\n        case -3: {\n          value = '\\r' + '\\n'\n          break\n        }\n\n        case -2: {\n          value = expandTabs ? ' ' : '\\t'\n          break\n        }\n\n        case -1: {\n          if (!expandTabs && atTab) continue\n          value = ' '\n          break\n        }\n\n        default: {\n          // Currently only replacement character.\n          value = String.fromCharCode(chunk)\n        }\n      }\n\n    atTab = chunk === -2\n    result.push(value)\n  }\n\n  return result.join('')\n}\n","/**\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {{resolveAll?: Resolver}[]} constructs\n * @param {Event[]} events\n * @param {TokenizeContext} context\n * @returns {Event[]}\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Resolver[]} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n */\nimport {\n  attention,\n  autolink,\n  blockQuote,\n  characterEscape,\n  characterReference,\n  codeFenced,\n  codeIndented,\n  codeText,\n  definition,\n  hardBreakEscape,\n  headingAtx,\n  htmlFlow,\n  htmlText,\n  labelEnd,\n  labelStartImage,\n  labelStartLink,\n  lineEnding,\n  list,\n  setextUnderline,\n  thematicBreak\n} from 'micromark-core-commonmark'\nimport {resolver as resolveText} from './initialize/text.js'\n/** @type {Extension['document']} */\n\nexport const document = {\n  [42]: list,\n  [43]: list,\n  [45]: list,\n  [48]: list,\n  [49]: list,\n  [50]: list,\n  [51]: list,\n  [52]: list,\n  [53]: list,\n  [54]: list,\n  [55]: list,\n  [56]: list,\n  [57]: list,\n  [62]: blockQuote\n}\n/** @type {Extension['contentInitial']} */\n\nexport const contentInitial = {\n  [91]: definition\n}\n/** @type {Extension['flowInitial']} */\n\nexport const flowInitial = {\n  [-2]: codeIndented,\n  [-1]: codeIndented,\n  [32]: codeIndented\n}\n/** @type {Extension['flow']} */\n\nexport const flow = {\n  [35]: headingAtx,\n  [42]: thematicBreak,\n  [45]: [setextUnderline, thematicBreak],\n  [60]: htmlFlow,\n  [61]: setextUnderline,\n  [95]: thematicBreak,\n  [96]: codeFenced,\n  [126]: codeFenced\n}\n/** @type {Extension['string']} */\n\nexport const string = {\n  [38]: characterReference,\n  [92]: characterEscape\n}\n/** @type {Extension['text']} */\n\nexport const text = {\n  [-5]: lineEnding,\n  [-4]: lineEnding,\n  [-3]: lineEnding,\n  [33]: labelStartImage,\n  [38]: characterReference,\n  [42]: attention,\n  [60]: [autolink, htmlText],\n  [91]: labelStartLink,\n  [92]: [hardBreakEscape, characterEscape],\n  [93]: labelEnd,\n  [95]: attention,\n  [96]: codeText\n}\n/** @type {Extension['insideSpan']} */\n\nexport const insideSpan = {\n  null: [attention, resolveText]\n}\n/** @type {Extension['attentionMarkers']} */\n\nexport const attentionMarkers = {\n  null: [42, 95]\n}\n/** @type {Extension['disable']} */\n\nexport const disable = {\n  null: []\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Point} Point\n */\nimport {push, splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n}\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n\nfunction resolveAllAttention(events, context) {\n  let index = -1\n  /** @type {number} */\n\n  let open\n  /** @type {Token} */\n\n  let group\n  /** @type {Token} */\n\n  let text\n  /** @type {Token} */\n\n  let openingSequence\n  /** @type {Token} */\n\n  let closingSequence\n  /** @type {number} */\n\n  let use\n  /** @type {Event[]} */\n\n  let nextEvents\n  /** @type {number} */\n\n  let offset // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but its\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open && // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then dont match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          } // Number of markers to use from the sequence.\n\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n          const start = Object.assign({}, events[open][1].end)\n          const end = Object.assign({}, events[index][1].start)\n          movePoint(start, -use)\n          movePoint(end, use)\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start,\n            end: Object.assign({}, events[open][1].end)\n          }\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end\n          }\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          }\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          }\n          events[open][1].end = Object.assign({}, openingSequence.start)\n          events[index][1].start = Object.assign({}, closingSequence.end)\n          nextEvents = [] // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          } // Opening.\n\n          nextEvents = push(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ]) // Between.\n\n          nextEvents = push(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          ) // Closing.\n\n          nextEvents = push(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ]) // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = push(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n\n          splice(events, open - 1, index - open + 3, nextEvents)\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n  index = -1\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null\n  const previous = this.previous\n  const before = classifyCharacter(previous)\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('attentionSequence')\n    marker = code\n    return sequence(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return sequence\n    }\n\n    const token = effects.exit('attentionSequence')\n    const after = classifyCharacter(code)\n    const open =\n      !after || (after === 2 && before) || attentionMarkers.includes(code)\n    const close =\n      !before || (before === 2 && after) || attentionMarkers.includes(previous)\n    token._open = Boolean(marker === 42 ? open : open && (before || !close))\n    token._close = Boolean(marker === 42 ? close : close && (after || !open))\n    return ok(code)\n  }\n}\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! Its not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */\n\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\n\n/**\n * Classify whether a character code represents whitespace, punctuation, or\n * something else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * Note that eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n * @returns {number|undefined}\n */\nexport function classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiAtext,\n  asciiControl\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const autolink = {\n  name: 'autolink',\n  tokenize: tokenizeAutolink\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeAutolink(effects, ok, nok) {\n  let size = 1\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('autolink')\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.enter('autolinkProtocol')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return schemeOrEmailAtext\n    }\n\n    return asciiAtext(code) ? emailAtext(code) : nok(code)\n  }\n  /** @type {State} */\n\n  function schemeOrEmailAtext(code) {\n    return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)\n      ? schemeInsideOrEmailAtext(code)\n      : emailAtext(code)\n  }\n  /** @type {State} */\n\n  function schemeInsideOrEmailAtext(code) {\n    if (code === 58) {\n      effects.consume(code)\n      return urlInside\n    }\n\n    if (\n      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&\n      size++ < 32\n    ) {\n      effects.consume(code)\n      return schemeInsideOrEmailAtext\n    }\n\n    return emailAtext(code)\n  }\n  /** @type {State} */\n\n  function urlInside(code) {\n    if (code === 62) {\n      effects.exit('autolinkProtocol')\n      return end(code)\n    }\n\n    if (code === null || code === 32 || code === 60 || asciiControl(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return urlInside\n  }\n  /** @type {State} */\n\n  function emailAtext(code) {\n    if (code === 64) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (asciiAtext(code)) {\n      effects.consume(code)\n      return emailAtext\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)\n  }\n  /** @type {State} */\n\n  function emailLabel(code) {\n    if (code === 46) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (code === 62) {\n      // Exit, then change the type.\n      effects.exit('autolinkProtocol').type = 'autolinkEmail'\n      return end(code)\n    }\n\n    return emailValue(code)\n  }\n  /** @type {State} */\n\n  function emailValue(code) {\n    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {\n      effects.consume(code)\n      return code === 45 ? emailValue : emailLabel\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.exit('autolink')\n    return ok\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 62) {\n      const state = self.containerState\n\n      if (!state.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        })\n        state.open = true\n      }\n\n      effects.enter('blockQuotePrefix')\n      effects.enter('blockQuoteMarker')\n      effects.consume(code)\n      effects.exit('blockQuoteMarker')\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace')\n      effects.consume(code)\n      effects.exit('blockQuotePrefixWhitespace')\n      effects.exit('blockQuotePrefix')\n      return ok\n    }\n\n    effects.exit('blockQuotePrefix')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(blockQuote, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n/** @type {Exiter} */\n\nfunction exit(effects) {\n  effects.exit('blockQuote')\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {asciiPunctuation} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const characterEscape = {\n  name: 'characterEscape',\n  tokenize: tokenizeCharacterEscape\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCharacterEscape(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('characterEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    effects.exit('escapeMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (asciiPunctuation(code)) {\n      effects.enter('characterEscapeValue')\n      effects.consume(code)\n      effects.exit('characterEscapeValue')\n      effects.exit('characterEscape')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {\n  asciiAlphanumeric,\n  asciiDigit,\n  asciiHexDigit\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  const self = this\n  let size = 0\n  /** @type {number} */\n\n  let max\n  /** @type {(code: Code) => code is number} */\n\n  let test\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('characterReference')\n    effects.enter('characterReferenceMarker')\n    effects.consume(code)\n    effects.exit('characterReferenceMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 35) {\n      effects.enter('characterReferenceMarkerNumeric')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerNumeric')\n      return numeric\n    }\n\n    effects.enter('characterReferenceValue')\n    max = 31\n    test = asciiAlphanumeric\n    return value(code)\n  }\n  /** @type {State} */\n\n  function numeric(code) {\n    if (code === 88 || code === 120) {\n      effects.enter('characterReferenceMarkerHexadecimal')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerHexadecimal')\n      effects.enter('characterReferenceValue')\n      max = 6\n      test = asciiHexDigit\n      return value\n    }\n\n    effects.enter('characterReferenceValue')\n    max = 7\n    test = asciiDigit\n    return value(code)\n  }\n  /** @type {State} */\n\n  function value(code) {\n    /** @type {Token} */\n    let token\n\n    if (code === 59 && size) {\n      token = effects.exit('characterReferenceValue')\n\n      if (\n        test === asciiAlphanumeric &&\n        !decodeNamedCharacterReference(self.sliceSerialize(token))\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('characterReferenceMarker')\n      effects.consume(code)\n      effects.exit('characterReferenceMarker')\n      effects.exit('characterReference')\n      return ok\n    }\n\n    if (test(code) && size++ < max) {\n      effects.consume(code)\n      return value\n    }\n\n    return nok(code)\n  }\n}\n","import {characterEntities} from 'character-entities'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Decode a single character reference (without the `&` or `;`).\n * You probably only need this when youre building parsers yourself that follow\n * different rules compared to HTML.\n * This is optimized to be tiny in browsers.\n *\n * @param {string} value\n *   `notin` (named), `#123` (deci), `#x123` (hexa).\n * @returns {string|false}\n *   Decoded reference.\n */\nexport function decodeNamedCharacterReference(value) {\n  return own.call(characterEntities, value) ? characterEntities[value] : false\n}\n","/**\n * Map of named character references.\n *\n * @type {Record<string, string>}\n */\nexport const characterEntities = {\n  AElig: '',\n  AMP: '&',\n  Aacute: '',\n  Abreve: '',\n  Acirc: '',\n  Acy: '',\n  Afr: '',\n  Agrave: '',\n  Alpha: '',\n  Amacr: '',\n  And: '',\n  Aogon: '',\n  Aopf: '',\n  ApplyFunction: '',\n  Aring: '',\n  Ascr: '',\n  Assign: '',\n  Atilde: '',\n  Auml: '',\n  Backslash: '',\n  Barv: '',\n  Barwed: '',\n  Bcy: '',\n  Because: '',\n  Bernoullis: '',\n  Beta: '',\n  Bfr: '',\n  Bopf: '',\n  Breve: '',\n  Bscr: '',\n  Bumpeq: '',\n  CHcy: '',\n  COPY: '',\n  Cacute: '',\n  Cap: '',\n  CapitalDifferentialD: '',\n  Cayleys: '',\n  Ccaron: '',\n  Ccedil: '',\n  Ccirc: '',\n  Cconint: '',\n  Cdot: '',\n  Cedilla: '',\n  CenterDot: '',\n  Cfr: '',\n  Chi: '',\n  CircleDot: '',\n  CircleMinus: '',\n  CirclePlus: '',\n  CircleTimes: '',\n  ClockwiseContourIntegral: '',\n  CloseCurlyDoubleQuote: '',\n  CloseCurlyQuote: '',\n  Colon: '',\n  Colone: '',\n  Congruent: '',\n  Conint: '',\n  ContourIntegral: '',\n  Copf: '',\n  Coproduct: '',\n  CounterClockwiseContourIntegral: '',\n  Cross: '',\n  Cscr: '',\n  Cup: '',\n  CupCap: '',\n  DD: '',\n  DDotrahd: '',\n  DJcy: '',\n  DScy: '',\n  DZcy: '',\n  Dagger: '',\n  Darr: '',\n  Dashv: '',\n  Dcaron: '',\n  Dcy: '',\n  Del: '',\n  Delta: '',\n  Dfr: '',\n  DiacriticalAcute: '',\n  DiacriticalDot: '',\n  DiacriticalDoubleAcute: '',\n  DiacriticalGrave: '`',\n  DiacriticalTilde: '',\n  Diamond: '',\n  DifferentialD: '',\n  Dopf: '',\n  Dot: '',\n  DotDot: '',\n  DotEqual: '',\n  DoubleContourIntegral: '',\n  DoubleDot: '',\n  DoubleDownArrow: '',\n  DoubleLeftArrow: '',\n  DoubleLeftRightArrow: '',\n  DoubleLeftTee: '',\n  DoubleLongLeftArrow: '',\n  DoubleLongLeftRightArrow: '',\n  DoubleLongRightArrow: '',\n  DoubleRightArrow: '',\n  DoubleRightTee: '',\n  DoubleUpArrow: '',\n  DoubleUpDownArrow: '',\n  DoubleVerticalBar: '',\n  DownArrow: '',\n  DownArrowBar: '',\n  DownArrowUpArrow: '',\n  DownBreve: '',\n  DownLeftRightVector: '',\n  DownLeftTeeVector: '',\n  DownLeftVector: '',\n  DownLeftVectorBar: '',\n  DownRightTeeVector: '',\n  DownRightVector: '',\n  DownRightVectorBar: '',\n  DownTee: '',\n  DownTeeArrow: '',\n  Downarrow: '',\n  Dscr: '',\n  Dstrok: '',\n  ENG: '',\n  ETH: '',\n  Eacute: '',\n  Ecaron: '',\n  Ecirc: '',\n  Ecy: '',\n  Edot: '',\n  Efr: '',\n  Egrave: '',\n  Element: '',\n  Emacr: '',\n  EmptySmallSquare: '',\n  EmptyVerySmallSquare: '',\n  Eogon: '',\n  Eopf: '',\n  Epsilon: '',\n  Equal: '',\n  EqualTilde: '',\n  Equilibrium: '',\n  Escr: '',\n  Esim: '',\n  Eta: '',\n  Euml: '',\n  Exists: '',\n  ExponentialE: '',\n  Fcy: '',\n  Ffr: '',\n  FilledSmallSquare: '',\n  FilledVerySmallSquare: '',\n  Fopf: '',\n  ForAll: '',\n  Fouriertrf: '',\n  Fscr: '',\n  GJcy: '',\n  GT: '>',\n  Gamma: '',\n  Gammad: '',\n  Gbreve: '',\n  Gcedil: '',\n  Gcirc: '',\n  Gcy: '',\n  Gdot: '',\n  Gfr: '',\n  Gg: '',\n  Gopf: '',\n  GreaterEqual: '',\n  GreaterEqualLess: '',\n  GreaterFullEqual: '',\n  GreaterGreater: '',\n  GreaterLess: '',\n  GreaterSlantEqual: '',\n  GreaterTilde: '',\n  Gscr: '',\n  Gt: '',\n  HARDcy: '',\n  Hacek: '',\n  Hat: '^',\n  Hcirc: '',\n  Hfr: '',\n  HilbertSpace: '',\n  Hopf: '',\n  HorizontalLine: '',\n  Hscr: '',\n  Hstrok: '',\n  HumpDownHump: '',\n  HumpEqual: '',\n  IEcy: '',\n  IJlig: '',\n  IOcy: '',\n  Iacute: '',\n  Icirc: '',\n  Icy: '',\n  Idot: '',\n  Ifr: '',\n  Igrave: '',\n  Im: '',\n  Imacr: '',\n  ImaginaryI: '',\n  Implies: '',\n  Int: '',\n  Integral: '',\n  Intersection: '',\n  InvisibleComma: '',\n  InvisibleTimes: '',\n  Iogon: '',\n  Iopf: '',\n  Iota: '',\n  Iscr: '',\n  Itilde: '',\n  Iukcy: '',\n  Iuml: '',\n  Jcirc: '',\n  Jcy: '',\n  Jfr: '',\n  Jopf: '',\n  Jscr: '',\n  Jsercy: '',\n  Jukcy: '',\n  KHcy: '',\n  KJcy: '',\n  Kappa: '',\n  Kcedil: '',\n  Kcy: '',\n  Kfr: '',\n  Kopf: '',\n  Kscr: '',\n  LJcy: '',\n  LT: '<',\n  Lacute: '',\n  Lambda: '',\n  Lang: '',\n  Laplacetrf: '',\n  Larr: '',\n  Lcaron: '',\n  Lcedil: '',\n  Lcy: '',\n  LeftAngleBracket: '',\n  LeftArrow: '',\n  LeftArrowBar: '',\n  LeftArrowRightArrow: '',\n  LeftCeiling: '',\n  LeftDoubleBracket: '',\n  LeftDownTeeVector: '',\n  LeftDownVector: '',\n  LeftDownVectorBar: '',\n  LeftFloor: '',\n  LeftRightArrow: '',\n  LeftRightVector: '',\n  LeftTee: '',\n  LeftTeeArrow: '',\n  LeftTeeVector: '',\n  LeftTriangle: '',\n  LeftTriangleBar: '',\n  LeftTriangleEqual: '',\n  LeftUpDownVector: '',\n  LeftUpTeeVector: '',\n  LeftUpVector: '',\n  LeftUpVectorBar: '',\n  LeftVector: '',\n  LeftVectorBar: '',\n  Leftarrow: '',\n  Leftrightarrow: '',\n  LessEqualGreater: '',\n  LessFullEqual: '',\n  LessGreater: '',\n  LessLess: '',\n  LessSlantEqual: '',\n  LessTilde: '',\n  Lfr: '',\n  Ll: '',\n  Lleftarrow: '',\n  Lmidot: '',\n  LongLeftArrow: '',\n  LongLeftRightArrow: '',\n  LongRightArrow: '',\n  Longleftarrow: '',\n  Longleftrightarrow: '',\n  Longrightarrow: '',\n  Lopf: '',\n  LowerLeftArrow: '',\n  LowerRightArrow: '',\n  Lscr: '',\n  Lsh: '',\n  Lstrok: '',\n  Lt: '',\n  Map: '',\n  Mcy: '',\n  MediumSpace: '',\n  Mellintrf: '',\n  Mfr: '',\n  MinusPlus: '',\n  Mopf: '',\n  Mscr: '',\n  Mu: '',\n  NJcy: '',\n  Nacute: '',\n  Ncaron: '',\n  Ncedil: '',\n  Ncy: '',\n  NegativeMediumSpace: '',\n  NegativeThickSpace: '',\n  NegativeThinSpace: '',\n  NegativeVeryThinSpace: '',\n  NestedGreaterGreater: '',\n  NestedLessLess: '',\n  NewLine: '\\n',\n  Nfr: '',\n  NoBreak: '',\n  NonBreakingSpace: '',\n  Nopf: '',\n  Not: '',\n  NotCongruent: '',\n  NotCupCap: '',\n  NotDoubleVerticalBar: '',\n  NotElement: '',\n  NotEqual: '',\n  NotEqualTilde: '',\n  NotExists: '',\n  NotGreater: '',\n  NotGreaterEqual: '',\n  NotGreaterFullEqual: '',\n  NotGreaterGreater: '',\n  NotGreaterLess: '',\n  NotGreaterSlantEqual: '',\n  NotGreaterTilde: '',\n  NotHumpDownHump: '',\n  NotHumpEqual: '',\n  NotLeftTriangle: '',\n  NotLeftTriangleBar: '',\n  NotLeftTriangleEqual: '',\n  NotLess: '',\n  NotLessEqual: '',\n  NotLessGreater: '',\n  NotLessLess: '',\n  NotLessSlantEqual: '',\n  NotLessTilde: '',\n  NotNestedGreaterGreater: '',\n  NotNestedLessLess: '',\n  NotPrecedes: '',\n  NotPrecedesEqual: '',\n  NotPrecedesSlantEqual: '',\n  NotReverseElement: '',\n  NotRightTriangle: '',\n  NotRightTriangleBar: '',\n  NotRightTriangleEqual: '',\n  NotSquareSubset: '',\n  NotSquareSubsetEqual: '',\n  NotSquareSuperset: '',\n  NotSquareSupersetEqual: '',\n  NotSubset: '',\n  NotSubsetEqual: '',\n  NotSucceeds: '',\n  NotSucceedsEqual: '',\n  NotSucceedsSlantEqual: '',\n  NotSucceedsTilde: '',\n  NotSuperset: '',\n  NotSupersetEqual: '',\n  NotTilde: '',\n  NotTildeEqual: '',\n  NotTildeFullEqual: '',\n  NotTildeTilde: '',\n  NotVerticalBar: '',\n  Nscr: '',\n  Ntilde: '',\n  Nu: '',\n  OElig: '',\n  Oacute: '',\n  Ocirc: '',\n  Ocy: '',\n  Odblac: '',\n  Ofr: '',\n  Ograve: '',\n  Omacr: '',\n  Omega: '',\n  Omicron: '',\n  Oopf: '',\n  OpenCurlyDoubleQuote: '',\n  OpenCurlyQuote: '',\n  Or: '',\n  Oscr: '',\n  Oslash: '',\n  Otilde: '',\n  Otimes: '',\n  Ouml: '',\n  OverBar: '',\n  OverBrace: '',\n  OverBracket: '',\n  OverParenthesis: '',\n  PartialD: '',\n  Pcy: '',\n  Pfr: '',\n  Phi: '',\n  Pi: '',\n  PlusMinus: '',\n  Poincareplane: '',\n  Popf: '',\n  Pr: '',\n  Precedes: '',\n  PrecedesEqual: '',\n  PrecedesSlantEqual: '',\n  PrecedesTilde: '',\n  Prime: '',\n  Product: '',\n  Proportion: '',\n  Proportional: '',\n  Pscr: '',\n  Psi: '',\n  QUOT: '\"',\n  Qfr: '',\n  Qopf: '',\n  Qscr: '',\n  RBarr: '',\n  REG: '',\n  Racute: '',\n  Rang: '',\n  Rarr: '',\n  Rarrtl: '',\n  Rcaron: '',\n  Rcedil: '',\n  Rcy: '',\n  Re: '',\n  ReverseElement: '',\n  ReverseEquilibrium: '',\n  ReverseUpEquilibrium: '',\n  Rfr: '',\n  Rho: '',\n  RightAngleBracket: '',\n  RightArrow: '',\n  RightArrowBar: '',\n  RightArrowLeftArrow: '',\n  RightCeiling: '',\n  RightDoubleBracket: '',\n  RightDownTeeVector: '',\n  RightDownVector: '',\n  RightDownVectorBar: '',\n  RightFloor: '',\n  RightTee: '',\n  RightTeeArrow: '',\n  RightTeeVector: '',\n  RightTriangle: '',\n  RightTriangleBar: '',\n  RightTriangleEqual: '',\n  RightUpDownVector: '',\n  RightUpTeeVector: '',\n  RightUpVector: '',\n  RightUpVectorBar: '',\n  RightVector: '',\n  RightVectorBar: '',\n  Rightarrow: '',\n  Ropf: '',\n  RoundImplies: '',\n  Rrightarrow: '',\n  Rscr: '',\n  Rsh: '',\n  RuleDelayed: '',\n  SHCHcy: '',\n  SHcy: '',\n  SOFTcy: '',\n  Sacute: '',\n  Sc: '',\n  Scaron: '',\n  Scedil: '',\n  Scirc: '',\n  Scy: '',\n  Sfr: '',\n  ShortDownArrow: '',\n  ShortLeftArrow: '',\n  ShortRightArrow: '',\n  ShortUpArrow: '',\n  Sigma: '',\n  SmallCircle: '',\n  Sopf: '',\n  Sqrt: '',\n  Square: '',\n  SquareIntersection: '',\n  SquareSubset: '',\n  SquareSubsetEqual: '',\n  SquareSuperset: '',\n  SquareSupersetEqual: '',\n  SquareUnion: '',\n  Sscr: '',\n  Star: '',\n  Sub: '',\n  Subset: '',\n  SubsetEqual: '',\n  Succeeds: '',\n  SucceedsEqual: '',\n  SucceedsSlantEqual: '',\n  SucceedsTilde: '',\n  SuchThat: '',\n  Sum: '',\n  Sup: '',\n  Superset: '',\n  SupersetEqual: '',\n  Supset: '',\n  THORN: '',\n  TRADE: '',\n  TSHcy: '',\n  TScy: '',\n  Tab: '\\t',\n  Tau: '',\n  Tcaron: '',\n  Tcedil: '',\n  Tcy: '',\n  Tfr: '',\n  Therefore: '',\n  Theta: '',\n  ThickSpace: '',\n  ThinSpace: '',\n  Tilde: '',\n  TildeEqual: '',\n  TildeFullEqual: '',\n  TildeTilde: '',\n  Topf: '',\n  TripleDot: '',\n  Tscr: '',\n  Tstrok: '',\n  Uacute: '',\n  Uarr: '',\n  Uarrocir: '',\n  Ubrcy: '',\n  Ubreve: '',\n  Ucirc: '',\n  Ucy: '',\n  Udblac: '',\n  Ufr: '',\n  Ugrave: '',\n  Umacr: '',\n  UnderBar: '_',\n  UnderBrace: '',\n  UnderBracket: '',\n  UnderParenthesis: '',\n  Union: '',\n  UnionPlus: '',\n  Uogon: '',\n  Uopf: '',\n  UpArrow: '',\n  UpArrowBar: '',\n  UpArrowDownArrow: '',\n  UpDownArrow: '',\n  UpEquilibrium: '',\n  UpTee: '',\n  UpTeeArrow: '',\n  Uparrow: '',\n  Updownarrow: '',\n  UpperLeftArrow: '',\n  UpperRightArrow: '',\n  Upsi: '',\n  Upsilon: '',\n  Uring: '',\n  Uscr: '',\n  Utilde: '',\n  Uuml: '',\n  VDash: '',\n  Vbar: '',\n  Vcy: '',\n  Vdash: '',\n  Vdashl: '',\n  Vee: '',\n  Verbar: '',\n  Vert: '',\n  VerticalBar: '',\n  VerticalLine: '|',\n  VerticalSeparator: '',\n  VerticalTilde: '',\n  VeryThinSpace: '',\n  Vfr: '',\n  Vopf: '',\n  Vscr: '',\n  Vvdash: '',\n  Wcirc: '',\n  Wedge: '',\n  Wfr: '',\n  Wopf: '',\n  Wscr: '',\n  Xfr: '',\n  Xi: '',\n  Xopf: '',\n  Xscr: '',\n  YAcy: '',\n  YIcy: '',\n  YUcy: '',\n  Yacute: '',\n  Ycirc: '',\n  Ycy: '',\n  Yfr: '',\n  Yopf: '',\n  Yscr: '',\n  Yuml: '',\n  ZHcy: '',\n  Zacute: '',\n  Zcaron: '',\n  Zcy: '',\n  Zdot: '',\n  ZeroWidthSpace: '',\n  Zeta: '',\n  Zfr: '',\n  Zopf: '',\n  Zscr: '',\n  aacute: '',\n  abreve: '',\n  ac: '',\n  acE: '',\n  acd: '',\n  acirc: '',\n  acute: '',\n  acy: '',\n  aelig: '',\n  af: '',\n  afr: '',\n  agrave: '',\n  alefsym: '',\n  aleph: '',\n  alpha: '',\n  amacr: '',\n  amalg: '',\n  amp: '&',\n  and: '',\n  andand: '',\n  andd: '',\n  andslope: '',\n  andv: '',\n  ang: '',\n  ange: '',\n  angle: '',\n  angmsd: '',\n  angmsdaa: '',\n  angmsdab: '',\n  angmsdac: '',\n  angmsdad: '',\n  angmsdae: '',\n  angmsdaf: '',\n  angmsdag: '',\n  angmsdah: '',\n  angrt: '',\n  angrtvb: '',\n  angrtvbd: '',\n  angsph: '',\n  angst: '',\n  angzarr: '',\n  aogon: '',\n  aopf: '',\n  ap: '',\n  apE: '',\n  apacir: '',\n  ape: '',\n  apid: '',\n  apos: \"'\",\n  approx: '',\n  approxeq: '',\n  aring: '',\n  ascr: '',\n  ast: '*',\n  asymp: '',\n  asympeq: '',\n  atilde: '',\n  auml: '',\n  awconint: '',\n  awint: '',\n  bNot: '',\n  backcong: '',\n  backepsilon: '',\n  backprime: '',\n  backsim: '',\n  backsimeq: '',\n  barvee: '',\n  barwed: '',\n  barwedge: '',\n  bbrk: '',\n  bbrktbrk: '',\n  bcong: '',\n  bcy: '',\n  bdquo: '',\n  becaus: '',\n  because: '',\n  bemptyv: '',\n  bepsi: '',\n  bernou: '',\n  beta: '',\n  beth: '',\n  between: '',\n  bfr: '',\n  bigcap: '',\n  bigcirc: '',\n  bigcup: '',\n  bigodot: '',\n  bigoplus: '',\n  bigotimes: '',\n  bigsqcup: '',\n  bigstar: '',\n  bigtriangledown: '',\n  bigtriangleup: '',\n  biguplus: '',\n  bigvee: '',\n  bigwedge: '',\n  bkarow: '',\n  blacklozenge: '',\n  blacksquare: '',\n  blacktriangle: '',\n  blacktriangledown: '',\n  blacktriangleleft: '',\n  blacktriangleright: '',\n  blank: '',\n  blk12: '',\n  blk14: '',\n  blk34: '',\n  block: '',\n  bne: '=',\n  bnequiv: '',\n  bnot: '',\n  bopf: '',\n  bot: '',\n  bottom: '',\n  bowtie: '',\n  boxDL: '',\n  boxDR: '',\n  boxDl: '',\n  boxDr: '',\n  boxH: '',\n  boxHD: '',\n  boxHU: '',\n  boxHd: '',\n  boxHu: '',\n  boxUL: '',\n  boxUR: '',\n  boxUl: '',\n  boxUr: '',\n  boxV: '',\n  boxVH: '',\n  boxVL: '',\n  boxVR: '',\n  boxVh: '',\n  boxVl: '',\n  boxVr: '',\n  boxbox: '',\n  boxdL: '',\n  boxdR: '',\n  boxdl: '',\n  boxdr: '',\n  boxh: '',\n  boxhD: '',\n  boxhU: '',\n  boxhd: '',\n  boxhu: '',\n  boxminus: '',\n  boxplus: '',\n  boxtimes: '',\n  boxuL: '',\n  boxuR: '',\n  boxul: '',\n  boxur: '',\n  boxv: '',\n  boxvH: '',\n  boxvL: '',\n  boxvR: '',\n  boxvh: '',\n  boxvl: '',\n  boxvr: '',\n  bprime: '',\n  breve: '',\n  brvbar: '',\n  bscr: '',\n  bsemi: '',\n  bsim: '',\n  bsime: '',\n  bsol: '\\\\',\n  bsolb: '',\n  bsolhsub: '',\n  bull: '',\n  bullet: '',\n  bump: '',\n  bumpE: '',\n  bumpe: '',\n  bumpeq: '',\n  cacute: '',\n  cap: '',\n  capand: '',\n  capbrcup: '',\n  capcap: '',\n  capcup: '',\n  capdot: '',\n  caps: '',\n  caret: '',\n  caron: '',\n  ccaps: '',\n  ccaron: '',\n  ccedil: '',\n  ccirc: '',\n  ccups: '',\n  ccupssm: '',\n  cdot: '',\n  cedil: '',\n  cemptyv: '',\n  cent: '',\n  centerdot: '',\n  cfr: '',\n  chcy: '',\n  check: '',\n  checkmark: '',\n  chi: '',\n  cir: '',\n  cirE: '',\n  circ: '',\n  circeq: '',\n  circlearrowleft: '',\n  circlearrowright: '',\n  circledR: '',\n  circledS: '',\n  circledast: '',\n  circledcirc: '',\n  circleddash: '',\n  cire: '',\n  cirfnint: '',\n  cirmid: '',\n  cirscir: '',\n  clubs: '',\n  clubsuit: '',\n  colon: ':',\n  colone: '',\n  coloneq: '',\n  comma: ',',\n  commat: '@',\n  comp: '',\n  compfn: '',\n  complement: '',\n  complexes: '',\n  cong: '',\n  congdot: '',\n  conint: '',\n  copf: '',\n  coprod: '',\n  copy: '',\n  copysr: '',\n  crarr: '',\n  cross: '',\n  cscr: '',\n  csub: '',\n  csube: '',\n  csup: '',\n  csupe: '',\n  ctdot: '',\n  cudarrl: '',\n  cudarrr: '',\n  cuepr: '',\n  cuesc: '',\n  cularr: '',\n  cularrp: '',\n  cup: '',\n  cupbrcap: '',\n  cupcap: '',\n  cupcup: '',\n  cupdot: '',\n  cupor: '',\n  cups: '',\n  curarr: '',\n  curarrm: '',\n  curlyeqprec: '',\n  curlyeqsucc: '',\n  curlyvee: '',\n  curlywedge: '',\n  curren: '',\n  curvearrowleft: '',\n  curvearrowright: '',\n  cuvee: '',\n  cuwed: '',\n  cwconint: '',\n  cwint: '',\n  cylcty: '',\n  dArr: '',\n  dHar: '',\n  dagger: '',\n  daleth: '',\n  darr: '',\n  dash: '',\n  dashv: '',\n  dbkarow: '',\n  dblac: '',\n  dcaron: '',\n  dcy: '',\n  dd: '',\n  ddagger: '',\n  ddarr: '',\n  ddotseq: '',\n  deg: '',\n  delta: '',\n  demptyv: '',\n  dfisht: '',\n  dfr: '',\n  dharl: '',\n  dharr: '',\n  diam: '',\n  diamond: '',\n  diamondsuit: '',\n  diams: '',\n  die: '',\n  digamma: '',\n  disin: '',\n  div: '',\n  divide: '',\n  divideontimes: '',\n  divonx: '',\n  djcy: '',\n  dlcorn: '',\n  dlcrop: '',\n  dollar: '$',\n  dopf: '',\n  dot: '',\n  doteq: '',\n  doteqdot: '',\n  dotminus: '',\n  dotplus: '',\n  dotsquare: '',\n  doublebarwedge: '',\n  downarrow: '',\n  downdownarrows: '',\n  downharpoonleft: '',\n  downharpoonright: '',\n  drbkarow: '',\n  drcorn: '',\n  drcrop: '',\n  dscr: '',\n  dscy: '',\n  dsol: '',\n  dstrok: '',\n  dtdot: '',\n  dtri: '',\n  dtrif: '',\n  duarr: '',\n  duhar: '',\n  dwangle: '',\n  dzcy: '',\n  dzigrarr: '',\n  eDDot: '',\n  eDot: '',\n  eacute: '',\n  easter: '',\n  ecaron: '',\n  ecir: '',\n  ecirc: '',\n  ecolon: '',\n  ecy: '',\n  edot: '',\n  ee: '',\n  efDot: '',\n  efr: '',\n  eg: '',\n  egrave: '',\n  egs: '',\n  egsdot: '',\n  el: '',\n  elinters: '',\n  ell: '',\n  els: '',\n  elsdot: '',\n  emacr: '',\n  empty: '',\n  emptyset: '',\n  emptyv: '',\n  emsp13: '',\n  emsp14: '',\n  emsp: '',\n  eng: '',\n  ensp: '',\n  eogon: '',\n  eopf: '',\n  epar: '',\n  eparsl: '',\n  eplus: '',\n  epsi: '',\n  epsilon: '',\n  epsiv: '',\n  eqcirc: '',\n  eqcolon: '',\n  eqsim: '',\n  eqslantgtr: '',\n  eqslantless: '',\n  equals: '=',\n  equest: '',\n  equiv: '',\n  equivDD: '',\n  eqvparsl: '',\n  erDot: '',\n  erarr: '',\n  escr: '',\n  esdot: '',\n  esim: '',\n  eta: '',\n  eth: '',\n  euml: '',\n  euro: '',\n  excl: '!',\n  exist: '',\n  expectation: '',\n  exponentiale: '',\n  fallingdotseq: '',\n  fcy: '',\n  female: '',\n  ffilig: '',\n  fflig: '',\n  ffllig: '',\n  ffr: '',\n  filig: '',\n  fjlig: 'fj',\n  flat: '',\n  fllig: '',\n  fltns: '',\n  fnof: '',\n  fopf: '',\n  forall: '',\n  fork: '',\n  forkv: '',\n  fpartint: '',\n  frac12: '',\n  frac13: '',\n  frac14: '',\n  frac15: '',\n  frac16: '',\n  frac18: '',\n  frac23: '',\n  frac25: '',\n  frac34: '',\n  frac35: '',\n  frac38: '',\n  frac45: '',\n  frac56: '',\n  frac58: '',\n  frac78: '',\n  frasl: '',\n  frown: '',\n  fscr: '',\n  gE: '',\n  gEl: '',\n  gacute: '',\n  gamma: '',\n  gammad: '',\n  gap: '',\n  gbreve: '',\n  gcirc: '',\n  gcy: '',\n  gdot: '',\n  ge: '',\n  gel: '',\n  geq: '',\n  geqq: '',\n  geqslant: '',\n  ges: '',\n  gescc: '',\n  gesdot: '',\n  gesdoto: '',\n  gesdotol: '',\n  gesl: '',\n  gesles: '',\n  gfr: '',\n  gg: '',\n  ggg: '',\n  gimel: '',\n  gjcy: '',\n  gl: '',\n  glE: '',\n  gla: '',\n  glj: '',\n  gnE: '',\n  gnap: '',\n  gnapprox: '',\n  gne: '',\n  gneq: '',\n  gneqq: '',\n  gnsim: '',\n  gopf: '',\n  grave: '`',\n  gscr: '',\n  gsim: '',\n  gsime: '',\n  gsiml: '',\n  gt: '>',\n  gtcc: '',\n  gtcir: '',\n  gtdot: '',\n  gtlPar: '',\n  gtquest: '',\n  gtrapprox: '',\n  gtrarr: '',\n  gtrdot: '',\n  gtreqless: '',\n  gtreqqless: '',\n  gtrless: '',\n  gtrsim: '',\n  gvertneqq: '',\n  gvnE: '',\n  hArr: '',\n  hairsp: '',\n  half: '',\n  hamilt: '',\n  hardcy: '',\n  harr: '',\n  harrcir: '',\n  harrw: '',\n  hbar: '',\n  hcirc: '',\n  hearts: '',\n  heartsuit: '',\n  hellip: '',\n  hercon: '',\n  hfr: '',\n  hksearow: '',\n  hkswarow: '',\n  hoarr: '',\n  homtht: '',\n  hookleftarrow: '',\n  hookrightarrow: '',\n  hopf: '',\n  horbar: '',\n  hscr: '',\n  hslash: '',\n  hstrok: '',\n  hybull: '',\n  hyphen: '',\n  iacute: '',\n  ic: '',\n  icirc: '',\n  icy: '',\n  iecy: '',\n  iexcl: '',\n  iff: '',\n  ifr: '',\n  igrave: '',\n  ii: '',\n  iiiint: '',\n  iiint: '',\n  iinfin: '',\n  iiota: '',\n  ijlig: '',\n  imacr: '',\n  image: '',\n  imagline: '',\n  imagpart: '',\n  imath: '',\n  imof: '',\n  imped: '',\n  in: '',\n  incare: '',\n  infin: '',\n  infintie: '',\n  inodot: '',\n  int: '',\n  intcal: '',\n  integers: '',\n  intercal: '',\n  intlarhk: '',\n  intprod: '',\n  iocy: '',\n  iogon: '',\n  iopf: '',\n  iota: '',\n  iprod: '',\n  iquest: '',\n  iscr: '',\n  isin: '',\n  isinE: '',\n  isindot: '',\n  isins: '',\n  isinsv: '',\n  isinv: '',\n  it: '',\n  itilde: '',\n  iukcy: '',\n  iuml: '',\n  jcirc: '',\n  jcy: '',\n  jfr: '',\n  jmath: '',\n  jopf: '',\n  jscr: '',\n  jsercy: '',\n  jukcy: '',\n  kappa: '',\n  kappav: '',\n  kcedil: '',\n  kcy: '',\n  kfr: '',\n  kgreen: '',\n  khcy: '',\n  kjcy: '',\n  kopf: '',\n  kscr: '',\n  lAarr: '',\n  lArr: '',\n  lAtail: '',\n  lBarr: '',\n  lE: '',\n  lEg: '',\n  lHar: '',\n  lacute: '',\n  laemptyv: '',\n  lagran: '',\n  lambda: '',\n  lang: '',\n  langd: '',\n  langle: '',\n  lap: '',\n  laquo: '',\n  larr: '',\n  larrb: '',\n  larrbfs: '',\n  larrfs: '',\n  larrhk: '',\n  larrlp: '',\n  larrpl: '',\n  larrsim: '',\n  larrtl: '',\n  lat: '',\n  latail: '',\n  late: '',\n  lates: '',\n  lbarr: '',\n  lbbrk: '',\n  lbrace: '{',\n  lbrack: '[',\n  lbrke: '',\n  lbrksld: '',\n  lbrkslu: '',\n  lcaron: '',\n  lcedil: '',\n  lceil: '',\n  lcub: '{',\n  lcy: '',\n  ldca: '',\n  ldquo: '',\n  ldquor: '',\n  ldrdhar: '',\n  ldrushar: '',\n  ldsh: '',\n  le: '',\n  leftarrow: '',\n  leftarrowtail: '',\n  leftharpoondown: '',\n  leftharpoonup: '',\n  leftleftarrows: '',\n  leftrightarrow: '',\n  leftrightarrows: '',\n  leftrightharpoons: '',\n  leftrightsquigarrow: '',\n  leftthreetimes: '',\n  leg: '',\n  leq: '',\n  leqq: '',\n  leqslant: '',\n  les: '',\n  lescc: '',\n  lesdot: '',\n  lesdoto: '',\n  lesdotor: '',\n  lesg: '',\n  lesges: '',\n  lessapprox: '',\n  lessdot: '',\n  lesseqgtr: '',\n  lesseqqgtr: '',\n  lessgtr: '',\n  lesssim: '',\n  lfisht: '',\n  lfloor: '',\n  lfr: '',\n  lg: '',\n  lgE: '',\n  lhard: '',\n  lharu: '',\n  lharul: '',\n  lhblk: '',\n  ljcy: '',\n  ll: '',\n  llarr: '',\n  llcorner: '',\n  llhard: '',\n  lltri: '',\n  lmidot: '',\n  lmoust: '',\n  lmoustache: '',\n  lnE: '',\n  lnap: '',\n  lnapprox: '',\n  lne: '',\n  lneq: '',\n  lneqq: '',\n  lnsim: '',\n  loang: '',\n  loarr: '',\n  lobrk: '',\n  longleftarrow: '',\n  longleftrightarrow: '',\n  longmapsto: '',\n  longrightarrow: '',\n  looparrowleft: '',\n  looparrowright: '',\n  lopar: '',\n  lopf: '',\n  loplus: '',\n  lotimes: '',\n  lowast: '',\n  lowbar: '_',\n  loz: '',\n  lozenge: '',\n  lozf: '',\n  lpar: '(',\n  lparlt: '',\n  lrarr: '',\n  lrcorner: '',\n  lrhar: '',\n  lrhard: '',\n  lrm: '',\n  lrtri: '',\n  lsaquo: '',\n  lscr: '',\n  lsh: '',\n  lsim: '',\n  lsime: '',\n  lsimg: '',\n  lsqb: '[',\n  lsquo: '',\n  lsquor: '',\n  lstrok: '',\n  lt: '<',\n  ltcc: '',\n  ltcir: '',\n  ltdot: '',\n  lthree: '',\n  ltimes: '',\n  ltlarr: '',\n  ltquest: '',\n  ltrPar: '',\n  ltri: '',\n  ltrie: '',\n  ltrif: '',\n  lurdshar: '',\n  luruhar: '',\n  lvertneqq: '',\n  lvnE: '',\n  mDDot: '',\n  macr: '',\n  male: '',\n  malt: '',\n  maltese: '',\n  map: '',\n  mapsto: '',\n  mapstodown: '',\n  mapstoleft: '',\n  mapstoup: '',\n  marker: '',\n  mcomma: '',\n  mcy: '',\n  mdash: '',\n  measuredangle: '',\n  mfr: '',\n  mho: '',\n  micro: '',\n  mid: '',\n  midast: '*',\n  midcir: '',\n  middot: '',\n  minus: '',\n  minusb: '',\n  minusd: '',\n  minusdu: '',\n  mlcp: '',\n  mldr: '',\n  mnplus: '',\n  models: '',\n  mopf: '',\n  mp: '',\n  mscr: '',\n  mstpos: '',\n  mu: '',\n  multimap: '',\n  mumap: '',\n  nGg: '',\n  nGt: '',\n  nGtv: '',\n  nLeftarrow: '',\n  nLeftrightarrow: '',\n  nLl: '',\n  nLt: '',\n  nLtv: '',\n  nRightarrow: '',\n  nVDash: '',\n  nVdash: '',\n  nabla: '',\n  nacute: '',\n  nang: '',\n  nap: '',\n  napE: '',\n  napid: '',\n  napos: '',\n  napprox: '',\n  natur: '',\n  natural: '',\n  naturals: '',\n  nbsp: '',\n  nbump: '',\n  nbumpe: '',\n  ncap: '',\n  ncaron: '',\n  ncedil: '',\n  ncong: '',\n  ncongdot: '',\n  ncup: '',\n  ncy: '',\n  ndash: '',\n  ne: '',\n  neArr: '',\n  nearhk: '',\n  nearr: '',\n  nearrow: '',\n  nedot: '',\n  nequiv: '',\n  nesear: '',\n  nesim: '',\n  nexist: '',\n  nexists: '',\n  nfr: '',\n  ngE: '',\n  nge: '',\n  ngeq: '',\n  ngeqq: '',\n  ngeqslant: '',\n  nges: '',\n  ngsim: '',\n  ngt: '',\n  ngtr: '',\n  nhArr: '',\n  nharr: '',\n  nhpar: '',\n  ni: '',\n  nis: '',\n  nisd: '',\n  niv: '',\n  njcy: '',\n  nlArr: '',\n  nlE: '',\n  nlarr: '',\n  nldr: '',\n  nle: '',\n  nleftarrow: '',\n  nleftrightarrow: '',\n  nleq: '',\n  nleqq: '',\n  nleqslant: '',\n  nles: '',\n  nless: '',\n  nlsim: '',\n  nlt: '',\n  nltri: '',\n  nltrie: '',\n  nmid: '',\n  nopf: '',\n  not: '',\n  notin: '',\n  notinE: '',\n  notindot: '',\n  notinva: '',\n  notinvb: '',\n  notinvc: '',\n  notni: '',\n  notniva: '',\n  notnivb: '',\n  notnivc: '',\n  npar: '',\n  nparallel: '',\n  nparsl: '',\n  npart: '',\n  npolint: '',\n  npr: '',\n  nprcue: '',\n  npre: '',\n  nprec: '',\n  npreceq: '',\n  nrArr: '',\n  nrarr: '',\n  nrarrc: '',\n  nrarrw: '',\n  nrightarrow: '',\n  nrtri: '',\n  nrtrie: '',\n  nsc: '',\n  nsccue: '',\n  nsce: '',\n  nscr: '',\n  nshortmid: '',\n  nshortparallel: '',\n  nsim: '',\n  nsime: '',\n  nsimeq: '',\n  nsmid: '',\n  nspar: '',\n  nsqsube: '',\n  nsqsupe: '',\n  nsub: '',\n  nsubE: '',\n  nsube: '',\n  nsubset: '',\n  nsubseteq: '',\n  nsubseteqq: '',\n  nsucc: '',\n  nsucceq: '',\n  nsup: '',\n  nsupE: '',\n  nsupe: '',\n  nsupset: '',\n  nsupseteq: '',\n  nsupseteqq: '',\n  ntgl: '',\n  ntilde: '',\n  ntlg: '',\n  ntriangleleft: '',\n  ntrianglelefteq: '',\n  ntriangleright: '',\n  ntrianglerighteq: '',\n  nu: '',\n  num: '#',\n  numero: '',\n  numsp: '',\n  nvDash: '',\n  nvHarr: '',\n  nvap: '',\n  nvdash: '',\n  nvge: '',\n  nvgt: '>',\n  nvinfin: '',\n  nvlArr: '',\n  nvle: '',\n  nvlt: '<',\n  nvltrie: '',\n  nvrArr: '',\n  nvrtrie: '',\n  nvsim: '',\n  nwArr: '',\n  nwarhk: '',\n  nwarr: '',\n  nwarrow: '',\n  nwnear: '',\n  oS: '',\n  oacute: '',\n  oast: '',\n  ocir: '',\n  ocirc: '',\n  ocy: '',\n  odash: '',\n  odblac: '',\n  odiv: '',\n  odot: '',\n  odsold: '',\n  oelig: '',\n  ofcir: '',\n  ofr: '',\n  ogon: '',\n  ograve: '',\n  ogt: '',\n  ohbar: '',\n  ohm: '',\n  oint: '',\n  olarr: '',\n  olcir: '',\n  olcross: '',\n  oline: '',\n  olt: '',\n  omacr: '',\n  omega: '',\n  omicron: '',\n  omid: '',\n  ominus: '',\n  oopf: '',\n  opar: '',\n  operp: '',\n  oplus: '',\n  or: '',\n  orarr: '',\n  ord: '',\n  order: '',\n  orderof: '',\n  ordf: '',\n  ordm: '',\n  origof: '',\n  oror: '',\n  orslope: '',\n  orv: '',\n  oscr: '',\n  oslash: '',\n  osol: '',\n  otilde: '',\n  otimes: '',\n  otimesas: '',\n  ouml: '',\n  ovbar: '',\n  par: '',\n  para: '',\n  parallel: '',\n  parsim: '',\n  parsl: '',\n  part: '',\n  pcy: '',\n  percnt: '%',\n  period: '.',\n  permil: '',\n  perp: '',\n  pertenk: '',\n  pfr: '',\n  phi: '',\n  phiv: '',\n  phmmat: '',\n  phone: '',\n  pi: '',\n  pitchfork: '',\n  piv: '',\n  planck: '',\n  planckh: '',\n  plankv: '',\n  plus: '+',\n  plusacir: '',\n  plusb: '',\n  pluscir: '',\n  plusdo: '',\n  plusdu: '',\n  pluse: '',\n  plusmn: '',\n  plussim: '',\n  plustwo: '',\n  pm: '',\n  pointint: '',\n  popf: '',\n  pound: '',\n  pr: '',\n  prE: '',\n  prap: '',\n  prcue: '',\n  pre: '',\n  prec: '',\n  precapprox: '',\n  preccurlyeq: '',\n  preceq: '',\n  precnapprox: '',\n  precneqq: '',\n  precnsim: '',\n  precsim: '',\n  prime: '',\n  primes: '',\n  prnE: '',\n  prnap: '',\n  prnsim: '',\n  prod: '',\n  profalar: '',\n  profline: '',\n  profsurf: '',\n  prop: '',\n  propto: '',\n  prsim: '',\n  prurel: '',\n  pscr: '',\n  psi: '',\n  puncsp: '',\n  qfr: '',\n  qint: '',\n  qopf: '',\n  qprime: '',\n  qscr: '',\n  quaternions: '',\n  quatint: '',\n  quest: '?',\n  questeq: '',\n  quot: '\"',\n  rAarr: '',\n  rArr: '',\n  rAtail: '',\n  rBarr: '',\n  rHar: '',\n  race: '',\n  racute: '',\n  radic: '',\n  raemptyv: '',\n  rang: '',\n  rangd: '',\n  range: '',\n  rangle: '',\n  raquo: '',\n  rarr: '',\n  rarrap: '',\n  rarrb: '',\n  rarrbfs: '',\n  rarrc: '',\n  rarrfs: '',\n  rarrhk: '',\n  rarrlp: '',\n  rarrpl: '',\n  rarrsim: '',\n  rarrtl: '',\n  rarrw: '',\n  ratail: '',\n  ratio: '',\n  rationals: '',\n  rbarr: '',\n  rbbrk: '',\n  rbrace: '}',\n  rbrack: ']',\n  rbrke: '',\n  rbrksld: '',\n  rbrkslu: '',\n  rcaron: '',\n  rcedil: '',\n  rceil: '',\n  rcub: '}',\n  rcy: '',\n  rdca: '',\n  rdldhar: '',\n  rdquo: '',\n  rdquor: '',\n  rdsh: '',\n  real: '',\n  realine: '',\n  realpart: '',\n  reals: '',\n  rect: '',\n  reg: '',\n  rfisht: '',\n  rfloor: '',\n  rfr: '',\n  rhard: '',\n  rharu: '',\n  rharul: '',\n  rho: '',\n  rhov: '',\n  rightarrow: '',\n  rightarrowtail: '',\n  rightharpoondown: '',\n  rightharpoonup: '',\n  rightleftarrows: '',\n  rightleftharpoons: '',\n  rightrightarrows: '',\n  rightsquigarrow: '',\n  rightthreetimes: '',\n  ring: '',\n  risingdotseq: '',\n  rlarr: '',\n  rlhar: '',\n  rlm: '',\n  rmoust: '',\n  rmoustache: '',\n  rnmid: '',\n  roang: '',\n  roarr: '',\n  robrk: '',\n  ropar: '',\n  ropf: '',\n  roplus: '',\n  rotimes: '',\n  rpar: ')',\n  rpargt: '',\n  rppolint: '',\n  rrarr: '',\n  rsaquo: '',\n  rscr: '',\n  rsh: '',\n  rsqb: ']',\n  rsquo: '',\n  rsquor: '',\n  rthree: '',\n  rtimes: '',\n  rtri: '',\n  rtrie: '',\n  rtrif: '',\n  rtriltri: '',\n  ruluhar: '',\n  rx: '',\n  sacute: '',\n  sbquo: '',\n  sc: '',\n  scE: '',\n  scap: '',\n  scaron: '',\n  sccue: '',\n  sce: '',\n  scedil: '',\n  scirc: '',\n  scnE: '',\n  scnap: '',\n  scnsim: '',\n  scpolint: '',\n  scsim: '',\n  scy: '',\n  sdot: '',\n  sdotb: '',\n  sdote: '',\n  seArr: '',\n  searhk: '',\n  searr: '',\n  searrow: '',\n  sect: '',\n  semi: ';',\n  seswar: '',\n  setminus: '',\n  setmn: '',\n  sext: '',\n  sfr: '',\n  sfrown: '',\n  sharp: '',\n  shchcy: '',\n  shcy: '',\n  shortmid: '',\n  shortparallel: '',\n  shy: '',\n  sigma: '',\n  sigmaf: '',\n  sigmav: '',\n  sim: '',\n  simdot: '',\n  sime: '',\n  simeq: '',\n  simg: '',\n  simgE: '',\n  siml: '',\n  simlE: '',\n  simne: '',\n  simplus: '',\n  simrarr: '',\n  slarr: '',\n  smallsetminus: '',\n  smashp: '',\n  smeparsl: '',\n  smid: '',\n  smile: '',\n  smt: '',\n  smte: '',\n  smtes: '',\n  softcy: '',\n  sol: '/',\n  solb: '',\n  solbar: '',\n  sopf: '',\n  spades: '',\n  spadesuit: '',\n  spar: '',\n  sqcap: '',\n  sqcaps: '',\n  sqcup: '',\n  sqcups: '',\n  sqsub: '',\n  sqsube: '',\n  sqsubset: '',\n  sqsubseteq: '',\n  sqsup: '',\n  sqsupe: '',\n  sqsupset: '',\n  sqsupseteq: '',\n  squ: '',\n  square: '',\n  squarf: '',\n  squf: '',\n  srarr: '',\n  sscr: '',\n  ssetmn: '',\n  ssmile: '',\n  sstarf: '',\n  star: '',\n  starf: '',\n  straightepsilon: '',\n  straightphi: '',\n  strns: '',\n  sub: '',\n  subE: '',\n  subdot: '',\n  sube: '',\n  subedot: '',\n  submult: '',\n  subnE: '',\n  subne: '',\n  subplus: '',\n  subrarr: '',\n  subset: '',\n  subseteq: '',\n  subseteqq: '',\n  subsetneq: '',\n  subsetneqq: '',\n  subsim: '',\n  subsub: '',\n  subsup: '',\n  succ: '',\n  succapprox: '',\n  succcurlyeq: '',\n  succeq: '',\n  succnapprox: '',\n  succneqq: '',\n  succnsim: '',\n  succsim: '',\n  sum: '',\n  sung: '',\n  sup1: '',\n  sup2: '',\n  sup3: '',\n  sup: '',\n  supE: '',\n  supdot: '',\n  supdsub: '',\n  supe: '',\n  supedot: '',\n  suphsol: '',\n  suphsub: '',\n  suplarr: '',\n  supmult: '',\n  supnE: '',\n  supne: '',\n  supplus: '',\n  supset: '',\n  supseteq: '',\n  supseteqq: '',\n  supsetneq: '',\n  supsetneqq: '',\n  supsim: '',\n  supsub: '',\n  supsup: '',\n  swArr: '',\n  swarhk: '',\n  swarr: '',\n  swarrow: '',\n  swnwar: '',\n  szlig: '',\n  target: '',\n  tau: '',\n  tbrk: '',\n  tcaron: '',\n  tcedil: '',\n  tcy: '',\n  tdot: '',\n  telrec: '',\n  tfr: '',\n  there4: '',\n  therefore: '',\n  theta: '',\n  thetasym: '',\n  thetav: '',\n  thickapprox: '',\n  thicksim: '',\n  thinsp: '',\n  thkap: '',\n  thksim: '',\n  thorn: '',\n  tilde: '',\n  times: '',\n  timesb: '',\n  timesbar: '',\n  timesd: '',\n  tint: '',\n  toea: '',\n  top: '',\n  topbot: '',\n  topcir: '',\n  topf: '',\n  topfork: '',\n  tosa: '',\n  tprime: '',\n  trade: '',\n  triangle: '',\n  triangledown: '',\n  triangleleft: '',\n  trianglelefteq: '',\n  triangleq: '',\n  triangleright: '',\n  trianglerighteq: '',\n  tridot: '',\n  trie: '',\n  triminus: '',\n  triplus: '',\n  trisb: '',\n  tritime: '',\n  trpezium: '',\n  tscr: '',\n  tscy: '',\n  tshcy: '',\n  tstrok: '',\n  twixt: '',\n  twoheadleftarrow: '',\n  twoheadrightarrow: '',\n  uArr: '',\n  uHar: '',\n  uacute: '',\n  uarr: '',\n  ubrcy: '',\n  ubreve: '',\n  ucirc: '',\n  ucy: '',\n  udarr: '',\n  udblac: '',\n  udhar: '',\n  ufisht: '',\n  ufr: '',\n  ugrave: '',\n  uharl: '',\n  uharr: '',\n  uhblk: '',\n  ulcorn: '',\n  ulcorner: '',\n  ulcrop: '',\n  ultri: '',\n  umacr: '',\n  uml: '',\n  uogon: '',\n  uopf: '',\n  uparrow: '',\n  updownarrow: '',\n  upharpoonleft: '',\n  upharpoonright: '',\n  uplus: '',\n  upsi: '',\n  upsih: '',\n  upsilon: '',\n  upuparrows: '',\n  urcorn: '',\n  urcorner: '',\n  urcrop: '',\n  uring: '',\n  urtri: '',\n  uscr: '',\n  utdot: '',\n  utilde: '',\n  utri: '',\n  utrif: '',\n  uuarr: '',\n  uuml: '',\n  uwangle: '',\n  vArr: '',\n  vBar: '',\n  vBarv: '',\n  vDash: '',\n  vangrt: '',\n  varepsilon: '',\n  varkappa: '',\n  varnothing: '',\n  varphi: '',\n  varpi: '',\n  varpropto: '',\n  varr: '',\n  varrho: '',\n  varsigma: '',\n  varsubsetneq: '',\n  varsubsetneqq: '',\n  varsupsetneq: '',\n  varsupsetneqq: '',\n  vartheta: '',\n  vartriangleleft: '',\n  vartriangleright: '',\n  vcy: '',\n  vdash: '',\n  vee: '',\n  veebar: '',\n  veeeq: '',\n  vellip: '',\n  verbar: '|',\n  vert: '|',\n  vfr: '',\n  vltri: '',\n  vnsub: '',\n  vnsup: '',\n  vopf: '',\n  vprop: '',\n  vrtri: '',\n  vscr: '',\n  vsubnE: '',\n  vsubne: '',\n  vsupnE: '',\n  vsupne: '',\n  vzigzag: '',\n  wcirc: '',\n  wedbar: '',\n  wedge: '',\n  wedgeq: '',\n  weierp: '',\n  wfr: '',\n  wopf: '',\n  wp: '',\n  wr: '',\n  wreath: '',\n  wscr: '',\n  xcap: '',\n  xcirc: '',\n  xcup: '',\n  xdtri: '',\n  xfr: '',\n  xhArr: '',\n  xharr: '',\n  xi: '',\n  xlArr: '',\n  xlarr: '',\n  xmap: '',\n  xnis: '',\n  xodot: '',\n  xopf: '',\n  xoplus: '',\n  xotime: '',\n  xrArr: '',\n  xrarr: '',\n  xscr: '',\n  xsqcup: '',\n  xuplus: '',\n  xutri: '',\n  xvee: '',\n  xwedge: '',\n  yacute: '',\n  yacy: '',\n  ycirc: '',\n  ycy: '',\n  yen: '',\n  yfr: '',\n  yicy: '',\n  yopf: '',\n  yscr: '',\n  yucy: '',\n  yuml: '',\n  zacute: '',\n  zcaron: '',\n  zcy: '',\n  zdot: '',\n  zeetrf: '',\n  zeta: '',\n  zfr: '',\n  zhcy: '',\n  zigrarr: '',\n  zopf: '',\n  zscr: '',\n  zwj: '',\n  zwnj: ''\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  }\n  /** @type {Construct} */\n\n  const nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  }\n  const tail = this.events[this.events.length - 1]\n  const initialPrefix =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeFenced')\n    effects.enter('codeFencedFence')\n    effects.enter('codeFencedFenceSequence')\n    marker = code\n    return sequenceOpen(code)\n  }\n  /** @type {State} */\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('codeFencedFenceSequence')\n    return sizeOpen < 3\n      ? nok(code)\n      : factorySpace(effects, infoOpen, 'whitespace')(code)\n  }\n  /** @type {State} */\n\n  function infoOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceInfo')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return info(code)\n  }\n  /** @type {State} */\n\n  function info(code) {\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return factorySpace(effects, infoAfter, 'whitespace')(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return info\n  }\n  /** @type {State} */\n\n  function infoAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n  /** @type {State} */\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n  /** @type {State} */\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence')\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n  /** @type {State} */\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          closingFenceConstruct,\n          after,\n          initialPrefix\n            ? factorySpace(\n                effects,\n                contentStart,\n                'linePrefix',\n                initialPrefix + 1\n              )\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return contentContinue(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeFenced')\n    return ok(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    return factorySpace(\n      effects,\n      closingSequenceStart,\n      'linePrefix',\n      this.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence')\n      effects.enter('codeFencedFenceSequence')\n      return closingSequence(code)\n    }\n    /** @type {State} */\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('codeFencedFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)\n    }\n    /** @type {State} */\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n}\n/** @type {Construct} */\n\nconst indentedContent = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeIndented')\n    return factorySpace(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code)\n  }\n  /** @type {State} */\n\n  function afterStartPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? afterPrefix(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(indentedContent, afterPrefix, after)(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return content(code)\n  }\n  /** @type {State} */\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return afterPrefix(code)\n    }\n\n    effects.consume(code)\n    return content\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeIndented')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // If this is a lazy line, it cant be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return start\n    }\n\n    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? ok(code)\n      : markdownLineEnding(code)\n      ? start(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous\n}\n/** @type {Resolver} */\n\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n\n  let index\n  /** @type {number|undefined} */\n\n  let enter // If we start and end with an EOL or a space.\n\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[headEnterIndex][1].type = 'codeTextPadding'\n        events[tailExitIndex][1].type = 'codeTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'codeTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n/** @type {Previous} */\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 96 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this\n  let sizeOpen = 0\n  /** @type {number} */\n\n  let size\n  /** @type {Token} */\n\n  let token\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeText')\n    effects.enter('codeTextSequence')\n    return openingSequence(code)\n  }\n  /** @type {State} */\n\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code)\n      sizeOpen++\n      return openingSequence\n    }\n\n    effects.exit('codeTextSequence')\n    return gap(code)\n  }\n  /** @type {State} */\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code)\n    } // Closing fence?\n    // Could also be data.\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence')\n      size = 0\n      return closingSequence(code)\n    } // Tabs dont work, and virtual spaces dont make sense.\n\n    if (code === 32) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return gap\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return gap\n    } // Data.\n\n    effects.enter('codeTextData')\n    return data(code)\n  } // In code.\n\n  /** @type {State} */\n\n  function data(code) {\n    if (\n      code === null ||\n      code === 32 ||\n      code === 96 ||\n      markdownLineEnding(code)\n    ) {\n      effects.exit('codeTextData')\n      return gap(code)\n    }\n\n    effects.consume(code)\n    return data\n  } // Closing fence.\n\n  /** @type {State} */\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code)\n      size++\n      return closingSequence\n    } // Done!\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence')\n      effects.exit('codeText')\n      return ok(code)\n    } // More or less accents: mark as data.\n\n    token.type = 'codeTextData'\n    return data(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n}\n/** @type {Construct} */\n\nconst titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this\n  /** @type {string} */\n\n  let identifier\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('definition')\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      nok,\n      'definitionLabel',\n      'definitionLabelMarker',\n      'definitionLabelString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Note: blank lines cant exist in content.\n\n      return factoryWhitespace(\n        effects,\n        factoryDestination(\n          effects,\n          effects.attempt(\n            titleConstruct,\n            factorySpace(effects, after, 'whitespace'),\n            factorySpace(effects, after, 'whitespace')\n          ),\n          nok,\n          'definitionDestination',\n          'definitionDestinationLiteral',\n          'definitionDestinationLiteralMarker',\n          'definitionDestinationRaw',\n          'definitionDestinationString'\n        )\n      )\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition')\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier)\n      }\n\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, before)(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factorySpace(effects, after, 'whitespace'),\n        nok,\n        'definitionTitle',\n        'definitionTitleMarker',\n        'definitionTitleString'\n      )(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\nimport {\n  asciiControl,\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} literalType\n * @param {string} literalMarkerType\n * @param {string} rawType\n * @param {string} stringType\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nexport function factoryDestination(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  const limit = max || Number.POSITIVE_INFINITY\n  let balance = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return destinationEnclosedBefore\n    }\n\n    if (code === null || code === 41 || asciiControl(code)) {\n      return nok(code)\n    }\n\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return destinationRaw(code)\n  }\n  /** @type {State} */\n\n  function destinationEnclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return destinationEnclosed(code)\n  }\n  /** @type {State} */\n\n  function destinationEnclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      return destinationEnclosedBefore(code)\n    }\n\n    if (code === null || code === 60 || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? destinationEnclosedEscape : destinationEnclosed\n  }\n  /** @type {State} */\n\n  function destinationEnclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code)\n      return destinationEnclosed\n    }\n\n    return destinationEnclosed(code)\n  }\n  /** @type {State} */\n\n  function destinationRaw(code) {\n    if (code === 40) {\n      if (++balance > limit) return nok(code)\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === 41) {\n      if (!balance--) {\n        effects.exit('chunkString')\n        effects.exit(stringType)\n        effects.exit(rawType)\n        effects.exit(type)\n        return ok(code)\n      }\n\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      if (balance) return nok(code)\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n\n    if (asciiControl(code)) return nok(code)\n    effects.consume(code)\n    return code === 92 ? destinationRawEscape : destinationRaw\n  }\n  /** @type {State} */\n\n  function destinationRawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    return destinationRaw(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n\n/**\n * @this {TokenizeContext}\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nexport function factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  const self = this\n  let size = 0\n  /** @type {boolean} */\n\n  let data\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    effects.enter(stringType)\n    return atBreak\n  }\n  /** @type {State} */\n\n  function atBreak(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      (code === 93 && !data) ||\n      /* To do: remove in the future once weve switched from\n       * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n       * which doesnt need this */\n\n      /* Hidden footnotes hook */\n\n      /* c8 ignore next 3 */\n      (code === 94 &&\n        !size &&\n        '_hiddenFootnoteSupport' in self.parser.constructs) ||\n      size > 999\n    ) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      effects.exit(stringType)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return atBreak\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return label(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      code === 93 ||\n      markdownLineEnding(code) ||\n      size++ > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n\n    effects.consume(code)\n    data = data || !markdownSpace(code)\n    return code === 92 ? labelEscape : label\n  }\n  /** @type {State} */\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return label\n    }\n\n    return label(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} markerType\n * @param {string} stringType\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nexport function factoryTitle(effects, ok, nok, type, markerType, stringType) {\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    marker = code === 40 ? 41 : code\n    return atFirstTitleBreak\n  }\n  /** @type {State} */\n\n  function atFirstTitleBreak(code) {\n    if (code === marker) {\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    return atTitleBreak(code)\n  }\n  /** @type {State} */\n\n  function atTitleBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType)\n      return atFirstTitleBreak(marker)\n    }\n\n    if (code === null) {\n      return nok(code)\n    } // Note: blank lines cant exist in content.\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, atTitleBreak, 'linePrefix')\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return title(code)\n  }\n  /** @type {State} */\n\n  function title(code) {\n    if (code === marker || code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      return atTitleBreak(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? titleEscape : title\n  }\n  /** @type {State} */\n\n  function titleEscape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code)\n      return title\n    }\n\n    return title(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n */\nexport function factoryWhitespace(effects, ok) {\n  /** @type {boolean} */\n  let seen\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      seen = true\n      return start\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        start,\n        seen ? 'linePrefix' : 'lineSuffix'\n      )(code)\n    }\n\n    return ok(code)\n  }\n}\n","/**\n * Normalize an identifier (such as used in definitions).\n *\n * @param {string} value\n * @returns {string}\n */\nexport function normalizeIdentifier(value) {\n  return (\n    value // Collapse Markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, ' ') // Trim.\n      .replace(/^ | $/g, '') // Some characters are considered uppercase, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const hardBreakEscape = {\n  name: 'hardBreakEscape',\n  tokenize: tokenizeHardBreakEscape\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHardBreakEscape(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('hardBreakEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (markdownLineEnding(code)) {\n      effects.exit('escapeMarker')\n      effects.exit('hardBreakEscape')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n/** @type {Resolver} */\n\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n\n  let content\n  /** @type {Token} */\n\n  let text // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  } // Suffix whitespace, part of the closing.\n\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      // @ts-expect-error Constants are fine to assign.\n      contentType: 'text'\n    }\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  const self = this\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('atxHeading')\n    effects.enter('atxHeadingSequence')\n    return fenceOpenInside(code)\n  }\n  /** @type {State} */\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return fenceOpenInside\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return self.interrupt ? ok(code) : headingBreak(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequence(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headingBreak, 'whitespace')(code)\n    }\n\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequence\n    }\n\n    effects.exit('atxHeadingSequence')\n    return headingBreak(code)\n  }\n  /** @type {State} */\n\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return headingBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {blankLine} from './blank-line.js'\n/** @type {Construct} */\n\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\n/** @type {Construct} */\n\nconst nextBlankConstruct = {\n  tokenize: tokenizeNextBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {\n      break\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === 'linePrefix') {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start // Add the prefix start to the HTML line token.\n\n    events[index + 1][1].start = events[index - 2][1].start // Remove the line prefix.\n\n    events.splice(index - 2, 2)\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n\n  let kind\n  /** @type {boolean} */\n\n  let startTag\n  /** @type {string} */\n\n  let buffer\n  /** @type {number} */\n\n  let index\n  /** @type {Code} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('htmlFlow')\n    effects.enter('htmlFlowData')\n    effects.consume(code)\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationStart\n    }\n\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      kind = 3 // While were in an instruction instead of a declaration, were on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      startTag = true\n      return tagName\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function declarationStart(code) {\n    if (code === 45) {\n      effects.consume(code)\n      kind = 2\n      return commentOpenInside\n    }\n\n    if (code === 91) {\n      effects.consume(code)\n      kind = 5\n      buffer = 'CDATA['\n      index = 0\n      return cdataOpenInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      kind = 4\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function cdataOpenInside(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length\n        ? self.interrupt\n          ? ok\n          : continuation\n        : cdataOpenInside\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagName(code) {\n    if (\n      code === null ||\n      code === 47 ||\n      code === 62 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      if (\n        code !== 47 &&\n        startTag &&\n        htmlRawNames.includes(buffer.toLowerCase())\n      ) {\n        kind = 1\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        kind = 6\n\n        if (code === 47) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      kind = 7 // Do not support complete HTML when interrupting\n\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : startTag\n        ? completeAttributeNameBefore(code)\n        : completeClosingTagAfter(code)\n    }\n\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function basicSelfClosing(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuation\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n\n    return completeEnd(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeNameBefore(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n\n    return completeEnd(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeName(code) {\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    return completeAttributeNameAfter(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n\n    return completeAttributeNameBefore(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return completeAttributeValueQuoted\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    marker = null\n    return completeAttributeValueUnquoted(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeValueQuoted(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    if (code === marker) {\n      effects.consume(code)\n      return completeAttributeValueQuotedAfter\n    }\n\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n  /** @type {State} */\n\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n  /** @type {State} */\n\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownSpace(code)) {\n      return completeAttributeNameBefore(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function completeEnd(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function completeAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return code === null || markdownLineEnding(code)\n      ? continuation(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function continuation(code) {\n    if (code === 45 && kind === 2) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n\n    if (code === 60 && kind === 1) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n\n    if (code === 62 && kind === 4) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (code === 63 && kind === 3) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    if (code === 93 && kind === 5) {\n      effects.consume(code)\n      return continuationCharacterDataInside\n    }\n\n    if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {\n      return effects.check(\n        nextBlankConstruct,\n        continuationClose,\n        continuationAtLineEnding\n      )(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      return continuationAtLineEnding(code)\n    }\n\n    effects.consume(code)\n    return continuation\n  }\n  /** @type {State} */\n\n  function continuationAtLineEnding(code) {\n    effects.exit('htmlFlowData')\n    return htmlContinueStart(code)\n  }\n  /** @type {State} */\n\n  function htmlContinueStart(code) {\n    if (code === null) {\n      return done(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        {\n          tokenize: htmlLineEnd,\n          partial: true\n        },\n        htmlContinueStart,\n        done\n      )(code)\n    }\n\n    effects.enter('htmlFlowData')\n    return continuation(code)\n  }\n  /** @type {Tokenizer} */\n\n  function htmlLineEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n  /** @type {State} */\n\n  function continuationCommentInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationRawTagOpen(code) {\n    if (code === 47) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationRawEndTag(code) {\n    if (code === 62 && htmlRawNames.includes(buffer.toLowerCase())) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (asciiAlpha(code) && buffer.length < 8) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationCharacterDataInside(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationDeclarationInside(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return continuationClose\n    } // More dashes.\n\n    if (code === 45 && kind === 2) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationClose(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return done(code)\n    }\n\n    effects.consume(code)\n    return continuationClose\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('htmlFlow')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextBlank(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.exit('htmlFlowData')\n    effects.enter('lineEndingBlank')\n    effects.consume(code)\n    effects.exit('lineEndingBlank')\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n","/**\n * List of lowercase HTML tag names which when parsing HTML (flow), result\n * in more relaxed rules (condition 6): because they are known blocks, the\n * HTML-like syntax doesnt have to be strictly parsed.\n * For tag names not in this list, a more strict algorithm (condition 7) is used\n * to detect whether the HTML-like syntax is seen as HTML (flow) or not.\n *\n * This is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n */\nexport const htmlBlockNames = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'section',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n]\n\n/**\n * List of lowercase HTML tag names which when parsing HTML (flow), result in\n * HTML that can include lines w/o exiting, until a closing tag also in this\n * list is found (condition 1).\n *\n * This module is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n *\n * Note that `textarea` was added in `CommonMark@0.30`.\n */\nexport const htmlRawNames = ['pre', 'script', 'style', 'textarea']\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>|undefined} */\n\n  let marker\n  /** @type {string} */\n\n  let buffer\n  /** @type {number} */\n\n  let index\n  /** @type {State} */\n\n  let returnState\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('htmlText')\n    effects.enter('htmlTextData')\n    effects.consume(code)\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      return instruction\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentOpen\n    }\n\n    if (code === 91) {\n      effects.consume(code)\n      buffer = 'CDATA['\n      index = 0\n      return cdataOpen\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function commentOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentStart\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function commentStart(code) {\n    if (code === null || code === 62) {\n      return nok(code)\n    }\n\n    if (code === 45) {\n      effects.consume(code)\n      return commentStartDash\n    }\n\n    return comment(code)\n  }\n  /** @type {State} */\n\n  function commentStartDash(code) {\n    if (code === null || code === 62) {\n      return nok(code)\n    }\n\n    return comment(code)\n  }\n  /** @type {State} */\n\n  function comment(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 45) {\n      effects.consume(code)\n      return commentClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return comment\n  }\n  /** @type {State} */\n\n  function commentClose(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return end\n    }\n\n    return comment(code)\n  }\n  /** @type {State} */\n\n  function cdataOpen(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length ? cdata : cdataOpen\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function cdata(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      effects.consume(code)\n      return cdataClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return cdata\n  }\n  /** @type {State} */\n\n  function cdataClose(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n  /** @type {State} */\n\n  function cdataEnd(code) {\n    if (code === 62) {\n      return end(code)\n    }\n\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n  /** @type {State} */\n\n  function declaration(code) {\n    if (code === null || code === 62) {\n      return end(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return declaration\n  }\n  /** @type {State} */\n\n  function instruction(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      return instructionClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return instruction\n  }\n  /** @type {State} */\n\n  function instructionClose(code) {\n    return code === 62 ? end(code) : instruction(code)\n  }\n  /** @type {State} */\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagClose(code) {\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return tagCloseBetween(code)\n  }\n  /** @type {State} */\n\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function tagOpen(code) {\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagOpenBetween(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return end\n    }\n\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeName(code) {\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    return tagOpenAttributeNameAfter(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n\n    return tagOpenBetween(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    effects.consume(code)\n    marker = undefined\n    return tagOpenAttributeValueUnquoted\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return tagOpenAttributeValueQuotedAfter\n    }\n\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  } // We cant have blank lines in content, so no need to worry about empty\n  // tokens.\n\n  /** @type {State} */\n\n  function atLineEnding(code) {\n    effects.exit('htmlTextData')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(\n      effects,\n      afterPrefix,\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    effects.enter('htmlTextData')\n    return returnState(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    if (code === 62) {\n      effects.consume(code)\n      effects.exit('htmlTextData')\n      effects.exit('htmlText')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n/** @type {Construct} */\n\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\n\nconst fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n}\n/** @type {Construct} */\n\nconst collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n}\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  /** @type {Token} */\n\n  let token\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n\n  return events\n}\n/** @type {Resolver} */\n\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n\n  let token\n  /** @type {number|undefined} */\n\n  let open\n  /** @type {number|undefined} */\n\n  let close\n  /** @type {Event[]} */\n\n  let media // Find an opening.\n\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, weve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      } // Mark other link openings as inactive, as we cant have links in\n      // links.\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ] // Opening marker.\n\n  media = push(media, events.slice(open + 1, open + offset + 3)) // Text open.\n\n  media = push(media, [['enter', text, context]]) // Between.\n\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  ) // Text close, marker close, label close.\n\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ]) // Reference, resource, or so.\n\n  media = push(media, events.slice(close + 1)) // Media close.\n\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n\n  let labelStart\n  /** @type {boolean} */\n\n  let defined // Find an opening.\n\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code)\n    } // Its a balanced bracket, but contains a link.\n\n    if (labelStart._inactive) return balanced(code)\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return afterLabelEnd\n  }\n  /** @type {State} */\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        ok,\n        defined ? ok : balanced\n      )(code)\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n    if (code === 91) {\n      return effects.attempt(\n        fullReferenceConstruct,\n        ok,\n        defined\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\n          : balanced\n      )(code)\n    } // Shortcut reference: `[asd]`?\n\n    return defined ? ok(code) : balanced(code)\n  }\n  /** @type {State} */\n\n  function balanced(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return factoryWhitespace(effects, open)\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 41) {\n      return end(code)\n    }\n\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      nok,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      32\n    )(code)\n  }\n  /** @type {State} */\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, between)(code)\n      : end(code)\n  }\n  /** @type {State} */\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factoryWhitespace(effects, end),\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function afterLabel(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {labelEnd} from './label-end.js'\n/** @type {Construct} */\n\nexport const labelStartImage = {\n  name: 'labelStartImage',\n  tokenize: tokenizeLabelStartImage,\n  resolveAll: labelEnd.resolveAll\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('labelImage')\n    effects.enter('labelImageMarker')\n    effects.consume(code)\n    effects.exit('labelImageMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 91) {\n      effects.enter('labelMarker')\n      effects.consume(code)\n      effects.exit('labelMarker')\n      effects.exit('labelImage')\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    /* To do: remove in the future once weve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesnt need this */\n\n    /* Hidden footnotes hook */\n\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {labelEnd} from './label-end.js'\n/** @type {Construct} */\n\nexport const labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: labelEnd.resolveAll\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('labelLink')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelLink')\n    return after\n  }\n  /** @type {State} */\n\n  function after(code) {\n    /* To do: remove in the future once weve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesnt need this */\n\n    /* Hidden footnotes hook. */\n\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const lineEnding = {\n  name: 'lineEnding',\n  tokenize: tokenizeLineEnding\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLineEnding(effects, ok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, ok, 'linePrefix')\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @typedef {Record<string, unknown> & {marker: Code, type: string, size: number}} ListContainerState\n * @typedef {TokenizeContext & {containerState: ListContainerState}} TokenizeContextWithState\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\nimport {blankLine} from './blank-line.js'\nimport {thematicBreak} from './thematic-break.js'\n/** @type {Construct} */\n\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\n/** @type {Construct} */\n\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\n/** @type {Construct} */\n\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  let initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    const kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n\n    return nok(code)\n  }\n  /**\n   * @type {State}\n   **/\n\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      blankLine, // Cant be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n  /** @type {State} */\n\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize +\n      self.sliceSerialize(effects.exit('listItemPrefix'), true).length\n    return ok(code)\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(blankLine, onBlank, notBlank)\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine // We have a blank line.\n    // Still, try to consume at most the items size.\n\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n  /** @type {State} */\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined\n      self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n\n    self.containerState.furtherBlankLines = undefined\n    self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n  /** @type {State} */\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true // As were closing flow, were no longer interrupting.\n\n    self.interrupt = undefined\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'listItemIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n/**\n * @type {Exiter}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : 4 + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return !markdownSpace(code) &&\n      tail &&\n      tail[1].type === 'listItemPrefixWhitespace'\n      ? ok(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  let size = 0\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('thematicBreak')\n    marker = code\n    return atBreak(code)\n  }\n  /** @type {State} */\n\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence')\n      return sequence(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, 'whitespace')(code)\n    }\n\n    if (size < 3 || (code !== null && !markdownLineEnding(code))) {\n      return nok(code)\n    }\n\n    effects.exit('thematicBreak')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      size++\n      return sequence\n    }\n\n    effects.exit('thematicBreakSequence')\n    return atBreak(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n/** @type {Resolver} */\n\nfunction resolveToSetextUnderline(events, context) {\n  let index = events.length\n  /** @type {number|undefined} */\n\n  let content\n  /** @type {number|undefined} */\n\n  let text\n  /** @type {number|undefined} */\n\n  let definition // Find the opening of the content.\n  // Itll always exist: we dont tokenize if it isnt there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed well add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  } // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText' // If we have definitions in the content, well keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  } // Add the heading exit at the end.\n\n  events.push(['exit', heading, context])\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  /** @type {boolean} */\n\n  let paragraph // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (\n      self.events[index][1].type !== 'lineEnding' &&\n      self.events[index][1].type !== 'linePrefix' &&\n      self.events[index][1].type !== 'content'\n    ) {\n      paragraph = self.events[index][1].type === 'paragraph'\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      effects.enter('setextHeadingLineSequence')\n      marker = code\n      return closingSequence(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return closingSequence\n    }\n\n    effects.exit('setextHeadingLineSequence')\n    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)\n  }\n  /** @type {State} */\n\n  function closingSequenceEnd(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @callback Preprocessor\n * @param {Value} value\n * @param {Encoding} [encoding]\n * @param {boolean} [end=false]\n * @returns {Array<Chunk>}\n */\nconst search = /[\\0\\t\\n\\r]/g\n/**\n * @returns {Preprocessor}\n */\n\nexport function preprocess() {\n  let column = 1\n  let buffer = ''\n  /** @type {boolean|undefined} */\n\n  let start = true\n  /** @type {boolean|undefined} */\n\n  let atCarriageReturn\n  return preprocessor\n  /** @type {Preprocessor} */\n\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = []\n    /** @type {RegExpMatchArray|null} */\n\n    let match\n    /** @type {number} */\n\n    let next\n    /** @type {number} */\n\n    let startPosition\n    /** @type {number} */\n\n    let endPosition\n    /** @type {Code} */\n\n    let code // @ts-expect-error `Buffer` does allow an encoding.\n\n    value = buffer + value.toString(encoding)\n    startPosition = 0\n    buffer = ''\n\n    if (start) {\n      if (value.charCodeAt(0) === 65279) {\n        startPosition++\n      }\n\n      start = undefined\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition\n      match = search.exec(value)\n      endPosition =\n        match && match.index !== undefined ? match.index : value.length\n      code = value.charCodeAt(endPosition)\n\n      if (!match) {\n        buffer = value.slice(startPosition)\n        break\n      }\n\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(-3)\n        atCarriageReturn = undefined\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(-5)\n          atCarriageReturn = undefined\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition))\n          column += endPosition - startPosition\n        }\n\n        switch (code) {\n          case 0: {\n            chunks.push(65533)\n            column++\n            break\n          }\n\n          case 9: {\n            next = Math.ceil(column / 4) * 4\n            chunks.push(-2)\n\n            while (column++ < next) chunks.push(-1)\n\n            break\n          }\n\n          case 10: {\n            chunks.push(-4)\n            column = 1\n            break\n          }\n\n          default: {\n            atCarriageReturn = true\n            column = 1\n          }\n        }\n      }\n\n      startPosition = endPosition + 1\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(-5)\n      if (buffer) chunks.push(buffer)\n      chunks.push(null)\n    }\n\n    return chunks\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n */\nimport {subtokenize} from 'micromark-util-subtokenize'\n/**\n * @param {Array<Event>} events\n * @returns {Array<Event>}\n */\n\nexport function postprocess(events) {\n  while (!subtokenize(events)) {\n    // Empty\n  }\n\n  return events\n}\n","/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base)\n\n  if (\n    // C0 except for HT, LF, FF, CR, space\n    code < 9 ||\n    code === 11 ||\n    (code > 13 && code < 32) || // Control character (DEL) of the basic block and C1 controls.\n    (code > 126 && code < 160) || // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) || // Noncharacters.\n    (code > 64975 && code < 65008) ||\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 || // Out of range\n    code > 1114111\n  ) {\n    return '\\uFFFD'\n  }\n\n  return String.fromCharCode(code)\n}\n","import {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nconst characterEscapeOrReference =\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n/**\n * Utility to decode markdown strings (which occur in places such as fenced\n * code info strings, destinations, labels, and titles).\n * The string content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n * @returns {string}\n */\n\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode)\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */\n\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1\n  } // Reference.\n\n  const head = $2.charCodeAt(0)\n\n  if (head === 35) {\n    const head = $2.charCodeAt(1)\n    const hex = head === 120 || head === 88\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)\n  }\n\n  return decodeNamedCharacterReference($2) || $0\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options\n */\n\nimport {gfm} from 'micromark-extension-gfm'\nimport {gfmFromMarkdown, gfmToMarkdown} from 'mdast-util-gfm'\n\n/**\n * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root>}\n */\nexport default function remarkGfm(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', gfm(options))\n  add('fromMarkdownExtensions', gfmFromMarkdown())\n  add('toMarkdownExtensions', gfmToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options\n * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions\n */\n\nimport {\n  combineExtensions,\n  combineHtmlExtensions\n} from 'micromark-util-combine-extensions'\nimport {\n  gfmAutolinkLiteral,\n  gfmAutolinkLiteralHtml\n} from 'micromark-extension-gfm-autolink-literal'\nimport {gfmFootnote, gfmFootnoteHtml} from 'micromark-extension-gfm-footnote'\nimport {\n  gfmStrikethrough,\n  gfmStrikethroughHtml\n} from 'micromark-extension-gfm-strikethrough'\nimport {gfmTable, gfmTableHtml} from 'micromark-extension-gfm-table'\nimport {gfmTagfilterHtml} from 'micromark-extension-gfm-tagfilter'\nimport {\n  gfmTaskListItem,\n  gfmTaskListItemHtml\n} from 'micromark-extension-gfm-task-list-item'\n\n/**\n * Support GFM or markdown on github.com.\n *\n * @param {Options} [options]\n * @returns {Extension}\n */\nexport function gfm(options) {\n  return combineExtensions([\n    gfmAutolinkLiteral,\n    gfmFootnote(),\n    gfmStrikethrough(options),\n    gfmTable,\n    gfmTaskListItem\n  ])\n}\n\n/**\n * Support to compile GFM to HTML.\n *\n * @param {HtmlOptions} [options]\n * @returns {HtmlExtension}\n */\nexport function gfmHtml(options) {\n  return combineHtmlExtensions([\n    gfmAutolinkLiteralHtml,\n    gfmFootnoteHtml(options),\n    gfmStrikethroughHtml,\n    gfmTableHtml,\n    gfmTagfilterHtml,\n    gfmTaskListItemHtml\n  ])\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiControl,\n  asciiDigit,\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nconst www = {\n  tokenize: tokenizeWww,\n  partial: true\n}\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n}\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n}\nconst punctuation = {\n  tokenize: tokenizePunctuation,\n  partial: true\n}\nconst namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n}\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n}\nconst httpAutolink = {\n  tokenize: tokenizeHttpAutolink,\n  previous: previousHttp\n}\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n}\n/** @type {ConstructRecord} */\n\nconst text = {}\n/** @type {Extension} */\n\nexport const gfmAutolinkLiteral = {\n  text\n}\nlet code = 48 // Add alphanumerics.\n\nwhile (code < 123) {\n  text[code] = emailAutolink\n  code++\n  if (code === 58) code = 65\n  else if (code === 91) code = 97\n}\n\ntext[43] = emailAutolink\ntext[45] = emailAutolink\ntext[46] = emailAutolink\ntext[95] = emailAutolink\ntext[72] = [emailAutolink, httpAutolink]\ntext[104] = [emailAutolink, httpAutolink]\ntext[87] = [emailAutolink, wwwAutolink]\ntext[119] = [emailAutolink, wwwAutolink]\n/** @type {Tokenizer} */\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this\n  /** @type {boolean} */\n\n  let hasDot\n  /** @type {boolean|undefined} */\n\n  let hasDigitInLastSegment\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      !gfmAtext(code) ||\n      !previousEmail(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n  /** @type {State} */\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n\n    if (code === 64) {\n      effects.consume(code)\n      return label\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function label(code) {\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code)\n    }\n\n    if (code === 45 || code === 95) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code)\n    }\n\n    if (asciiAlphanumeric(code)) {\n      if (!hasDigitInLastSegment && asciiDigit(code)) {\n        hasDigitInLastSegment = true\n      }\n\n      effects.consume(code)\n      return label\n    }\n\n    return done(code)\n  }\n  /** @type {State} */\n\n  function dotContinuation(code) {\n    effects.consume(code)\n    hasDot = true\n    hasDigitInLastSegment = undefined\n    return label\n  }\n  /** @type {State} */\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code)\n    return afterDashOrUnderscore\n  }\n  /** @type {State} */\n\n  function afterDashOrUnderscore(code) {\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code)\n    }\n\n    return label(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (hasDot && !hasDigitInLastSegment) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      (code !== 87 && code !== 119) ||\n      !previousWww(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww') // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but thats not how its implemented by them).\n\n    return effects.check(\n      www,\n      effects.attempt(domain, effects.attempt(path, done), nok),\n      nok\n    )(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (\n      (code !== 72 && code !== 104) ||\n      !previousHttp(self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkHttp')\n    effects.consume(code)\n    return t1\n  }\n  /** @type {State} */\n\n  function t1(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code)\n      return t2\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function t2(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code)\n      return p\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function p(code) {\n    if (code === 80 || code === 112) {\n      effects.consume(code)\n      return s\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function s(code) {\n    if (code === 83 || code === 115) {\n      effects.consume(code)\n      return colon\n    }\n\n    return colon(code)\n  }\n  /** @type {State} */\n\n  function colon(code) {\n    if (code === 58) {\n      effects.consume(code)\n      return slash1\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function slash1(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return slash2\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function slash2(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null ||\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, done), nok)(code)\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return w2\n  }\n  /** @type {State} */\n\n  function w2(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code)\n      return w3\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function w3(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code)\n      return dot\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function dot(code) {\n    if (code === 46) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? nok(code) : ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean|undefined} */\n  let hasUnderscoreInLastSegment\n  /** @type {boolean|undefined} */\n\n  let hasUnderscoreInLastLastSegment\n  return domain\n  /** @type {State} */\n\n  function domain(code) {\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        done,\n        punctuationContinuation\n      )(code)\n    }\n\n    if (code === 46 || code === 95) {\n      return effects.check(punctuation, done, punctuationContinuation)(code)\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www..com`,\n    // so thats Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n\n    if (\n      code === null ||\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      (code !== 45 && unicodePunctuation(code))\n    ) {\n      return done(code)\n    }\n\n    effects.consume(code)\n    return domain\n  }\n  /** @type {State} */\n\n  function punctuationContinuation(code) {\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment\n      hasUnderscoreInLastSegment = undefined\n      effects.consume(code)\n      return domain\n    }\n\n    if (code === 95) hasUnderscoreInLastSegment = true\n    effects.consume(code)\n    return domain\n  }\n  /** @type {State} */\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePath(effects, ok) {\n  let balance = 0\n  return inPath\n  /** @type {State} */\n\n  function inPath(code) {\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        ok,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (code === 40) {\n      balance++\n    }\n\n    if (code === 41) {\n      return effects.check(\n        punctuation,\n        parenAtPathEnd,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (pathEnd(code)) {\n      return ok(code)\n    }\n\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code)\n    }\n\n    effects.consume(code)\n    return inPath\n  }\n  /** @type {State} */\n\n  function continuedPunctuation(code) {\n    effects.consume(code)\n    return inPath\n  }\n  /** @type {State} */\n\n  function parenAtPathEnd(code) {\n    balance--\n    return balance < 0 ? ok(code) : continuedPunctuation(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return inside\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (code === 59) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, its\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code)\n    return after\n  }\n  /** @type {State} */\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code)\n      return after\n    } // If the punctuation marker is followed by the end of the path, its not\n    // continued punctuation.\n\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction trailingPunctuation(code) {\n  return (\n    code === 33 ||\n    code === 34 ||\n    code === 39 ||\n    code === 41 ||\n    code === 42 ||\n    code === 44 ||\n    code === 46 ||\n    code === 58 ||\n    code === 59 ||\n    code === 60 ||\n    code === 63 ||\n    code === 95 ||\n    code === 126\n  )\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction pathEnd(code) {\n  return code === null || code === 60 || markdownLineEndingOrSpace(code)\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\nfunction gfmAtext(code) {\n  return (\n    code === 43 ||\n    code === 45 ||\n    code === 46 ||\n    code === 95 ||\n    asciiAlphanumeric(code)\n  )\n}\n/** @type {Previous} */\n\nfunction previousWww(code) {\n  return (\n    code === null ||\n    code === 40 ||\n    code === 42 ||\n    code === 95 ||\n    code === 126 ||\n    markdownLineEndingOrSpace(code)\n  )\n}\n/** @type {Previous} */\n\nfunction previousHttp(code) {\n  return code === null || !asciiAlpha(code)\n}\n/** @type {Previous} */\n\nfunction previousEmail(code) {\n  return code !== 47 && previousHttp(code)\n}\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\n\nfunction previousUnbalanced(events) {\n  let index = events.length\n  let result = false\n\n  while (index--) {\n    const token = events[index][1]\n\n    if (\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\n      !token._balanced\n    ) {\n      result = true\n      break\n    } // @ts-expect-error If weve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false\n      break\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as walked into w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\n  }\n\n  return result\n}\n","/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').Handle} Handle\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * @typedef {import('micromark-util-types').Token} Token\n */\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\n/** @type {HtmlExtension} */\n\nexport const gfmAutolinkLiteralHtml = {\n  exit: {\n    literalAutolinkEmail,\n    literalAutolinkHttp,\n    literalAutolinkWww\n  }\n}\n/** @type {Handle} */\n\nfunction literalAutolinkWww(token) {\n  anchorFromToken.call(this, token, 'http://')\n}\n/** @type {Handle} */\n\nfunction literalAutolinkEmail(token) {\n  anchorFromToken.call(this, token, 'mailto:')\n}\n/** @type {Handle} */\n\nfunction literalAutolinkHttp(token) {\n  anchorFromToken.call(this, token)\n}\n/**\n * @this CompileContext\n * @param {Token} token\n * @param {string} [protocol]\n * @returns {void}\n */\n\nfunction anchorFromToken(token, protocol) {\n  const url = this.sliceSerialize(token)\n  this.tag('<a href=\"' + sanitizeUri((protocol || '') + url) + '\">')\n  this.raw(this.encode(url))\n  this.tag('</a>')\n}\n","import {asciiAlphanumeric} from 'micromark-util-character'\nimport {encode} from 'micromark-util-encode'\n\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri` below).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * Then, a regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`,\n * or `/^https?$/i` for `img[src]`.\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string|undefined} url\n * @param {RegExp} [protocol]\n * @returns {string}\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''))\n\n  if (!protocol) {\n    return value\n  }\n\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n\n  if (\n    // If there is no protocol, its relative.\n    colon < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign) || // It is a protocol, it should be allowed.\n    protocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n\n  return ''\n}\n/**\n * Normalize a URL (such as used in definitions).\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n * @returns {string}\n */\n\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n  let start = 0\n  let skip = 0\n\n  while (++index < value.length) {\n    const code = value.charCodeAt(index)\n    /** @type {string} */\n\n    let replace = '' // A correct percent encoded value.\n\n    if (\n      code === 37 &&\n      asciiAlphanumeric(value.charCodeAt(index + 1)) &&\n      asciiAlphanumeric(value.charCodeAt(index + 2))\n    ) {\n      skip = 2\n    } // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code)\n      }\n    } // Astral.\n    else if (code > 55295 && code < 57344) {\n      const next = value.charCodeAt(index + 1) // A correct surrogate pair.\n\n      if (code < 56320 && next > 56319 && next < 57344) {\n        replace = String.fromCharCode(code, next)\n        skip = 1\n      } // Lone surrogate.\n      else {\n        replace = '\\uFFFD'\n      }\n    } // Unicode.\n    else {\n      replace = String.fromCharCode(code)\n    }\n\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace))\n      start = index + skip + 1\n      replace = ''\n    }\n\n    if (skip) {\n      index += skip\n      skip = 0\n    }\n  }\n\n  return result.join('') + value.slice(start)\n}\n","const characterReferences = {'\"': 'quot', '&': 'amp', '<': 'lt', '>': 'gt'}\n\n/**\n * Encode only the dangerous HTML characters.\n *\n * This ensures that certain characters which have special meaning in HTML are\n * dealt with.\n * Technically, we can skip `>` and `\"` in many cases, but CM includes them.\n *\n * @param {string} value\n * @returns {string}\n */\nexport function encode(value) {\n  return value.replace(/[\"&<>]/g, replace)\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  function replace(value) {\n    // @ts-expect-error Hush, its fine.\n    return '&' + characterReferences[value] + ';'\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n\n// To do: remove after micromark update.\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Array<string>} */\n  // @ts-expect-error Its fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1]\n    if (token.type === 'labelImage') {\n      labelStart = token\n      break\n    }\n\n    // Exit if weve walked far enough.\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === 'labelLink' ||\n      token.type === 'label' ||\n      token.type === 'image' ||\n      token.type === 'link'\n    ) {\n      break\n    }\n  }\n  return start\n\n  /**\n   * @type {State}\n   */\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n    const id = normalizeIdentifier(\n      self.sliceSerialize({\n        start: labelStart.end,\n        end: self.now()\n      })\n    )\n    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token | undefined} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    if (\n      events[index][1].type === 'labelImage' &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = 'data'\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\n\n  // The whole (without `!`):\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  // The `^` marker\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }\n  // Increment the end 1 character.\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  const chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n\n  /** @type {Array<Event>} */\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context],\n    // The `[`\n    events[index + 3],\n    events[index + 4],\n    // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context],\n    // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context],\n    // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n  events.splice(index, events.length - index + 1, ...replacement)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error Its fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n  let data\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We cant do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start\n\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callStart(code) {\n    if (code !== 94) return nok(code)\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callData(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteCallString')\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code)\n      }\n      effects.enter('gfmFootnoteCallLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteCallLabelMarker')\n      effects.exit('gfmFootnoteCall')\n      return ok\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? callEscape : callData\n  }\n\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n    return callData(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error Its fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n  let identifier\n  let size = 0\n  /** @type {boolean | undefined} */\n  let data\n  return start\n\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelAtMarker\n  }\n\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAtMarker(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      effects.enter('chunkString').contentType = 'string'\n      return labelInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In label.\n   *\n   * >  **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * >  **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n    return labelInside(code)\n  }\n\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker')\n      if (!defined.includes(identifier)) {\n        defined.push(identifier)\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(\n        effects,\n        whitespaceAfter,\n        'gfmFootnoteDefinitionWhitespace'\n      )\n    }\n    return nok(code)\n  }\n\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    4 + 1\n  )\n\n  /**\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === 4\n      ? ok(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @callback BackLabelTemplate\n *   Generate a back label dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   * `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   * `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   * `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Back label to use when linking back from definitions to their reference.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {string} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute on footnotes to prevent them from\n *   *clobbering*.\n *\n *   The default is `'user-content-'`.\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {string} [label='Footnotes']\n *   Textual label to use for the footnotes section.\n *\n *   The default value is `'Footnotes'`.\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different attributes with the `labelAttributes` option.\n * @property {string} [labelAttributes='class=\"sr-only\"']\n *   Attributes to use on the footnote label.\n *\n *   Change it to show the label and add other attributes.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different attributes.\n *\n *   >  **Note**: `id=\"footnote-label\"` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string} [labelTagName='h2']\n *   HTML tag name to use for the footnote label element.\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different attributes with the `labelAttributes` option.\n * @property {BackLabelTemplate | string} [backLabel]\n *   Textual label to describe the backreference back to references.\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *  }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `aria-label` attribute on each backreference\n *   (the `` links).\n *   It affects users of assistive technology.\n */\n\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Generate the default label that GitHub uses on backreferences.\n *\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Default label.\n */\nexport function defaultBackLabel(referenceIndex, rereferenceIndex) {\n  return (\n    'Back to reference ' +\n    (referenceIndex + 1) +\n    (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n  )\n}\n\n/**\n * Create an extension for `micromark` to support GFM footnotes when\n * serializing to HTML.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM footnotes when serializing to HTML.\n */\nexport function gfmFootnoteHtml(options) {\n  const config = options || emptyOptions\n  const label = config.label || 'Footnotes'\n  const labelTagName = config.labelTagName || 'h2'\n  const labelAttributes =\n    config.labelAttributes === null || config.labelAttributes === undefined\n      ? 'class=\"sr-only\"'\n      : config.labelAttributes\n  const backLabel = config.backLabel || defaultBackLabel\n  const clobberPrefix =\n    config.clobberPrefix === null || config.clobberPrefix === undefined\n      ? 'user-content-'\n      : config.clobberPrefix\n  return {\n    enter: {\n      gfmFootnoteDefinition() {\n        const stack = /** @type {Array<boolean>} */ this.getData('tightStack')\n        stack.push(false)\n      },\n      gfmFootnoteDefinitionLabelString() {\n        this.buffer()\n      },\n      gfmFootnoteCallString() {\n        this.buffer()\n      }\n    },\n    exit: {\n      gfmFootnoteDefinition() {\n        let definitions =\n          /** @type {Record<string, string>} */\n          this.getData('gfmFootnoteDefinitions')\n        const footnoteStack =\n          /** @type {Array<string>} */\n          this.getData('gfmFootnoteDefinitionStack')\n        const tightStack =\n          /** @type {Array<boolean>} */\n          this.getData('tightStack')\n        const current = footnoteStack.pop()\n        const value = this.resume()\n        if (!definitions) {\n          this.setData('gfmFootnoteDefinitions', (definitions = {}))\n        }\n        if (!own.call(definitions, current)) definitions[current] = value\n        tightStack.pop()\n        this.setData('slurpOneLineEnding', true)\n        // Hack to prevent a line ending from showing up if were in a definition in\n        // an empty list item.\n        this.setData('lastWasTag')\n      },\n      gfmFootnoteDefinitionLabelString(token) {\n        let footnoteStack =\n          /** @type {Array<string>} */\n          this.getData('gfmFootnoteDefinitionStack')\n        if (!footnoteStack) {\n          this.setData('gfmFootnoteDefinitionStack', (footnoteStack = []))\n        }\n        footnoteStack.push(normalizeIdentifier(this.sliceSerialize(token)))\n        this.resume() // Drop the label.\n        this.buffer() // Get ready for a value.\n      },\n\n      gfmFootnoteCallString(token) {\n        let calls =\n          /** @type {Array<string>|undefined} */\n          this.getData('gfmFootnoteCallOrder')\n        let counts =\n          /** @type {Record<string, number>|undefined} */\n          this.getData('gfmFootnoteCallCounts')\n        const id = normalizeIdentifier(this.sliceSerialize(token))\n        /** @type {number} */\n        let counter\n        this.resume()\n        if (!calls) this.setData('gfmFootnoteCallOrder', (calls = []))\n        if (!counts) this.setData('gfmFootnoteCallCounts', (counts = {}))\n        const index = calls.indexOf(id)\n        const safeId = sanitizeUri(id.toLowerCase())\n        if (index === -1) {\n          calls.push(id)\n          counts[id] = 1\n          counter = calls.length\n        } else {\n          counts[id]++\n          counter = index + 1\n        }\n        const reuseCounter = counts[id]\n        this.tag(\n          '<sup><a href=\"#' +\n            clobberPrefix +\n            'fn-' +\n            safeId +\n            '\" id=\"' +\n            clobberPrefix +\n            'fnref-' +\n            safeId +\n            (reuseCounter > 1 ? '-' + reuseCounter : '') +\n            '\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">' +\n            String(counter) +\n            '</a></sup>'\n        )\n      },\n      null() {\n        const calls =\n          /** @type {Array<string>} */\n          this.getData('gfmFootnoteCallOrder') || []\n        const counts =\n          /** @type {Record<string, number>} */\n          this.getData('gfmFootnoteCallCounts') || {}\n        const definitions =\n          /** @type {Record<string, string>} */\n          this.getData('gfmFootnoteDefinitions') || {}\n        let index = -1\n        if (calls.length > 0) {\n          this.lineEndingIfNeeded()\n          this.tag(\n            '<section data-footnotes=\"\" class=\"footnotes\"><' +\n              labelTagName +\n              ' id=\"footnote-label\"' +\n              (labelAttributes ? ' ' + labelAttributes : '') +\n              '>'\n          )\n          this.raw(this.encode(label))\n          this.tag('</' + labelTagName + '>')\n          this.lineEndingIfNeeded()\n          this.tag('<ol>')\n        }\n        while (++index < calls.length) {\n          // Called definitions are always defined.\n          const id = calls[index]\n          const safeId = sanitizeUri(id.toLowerCase())\n          let referenceIndex = 0\n          /** @type {Array<string>} */\n          const references = []\n          while (++referenceIndex <= counts[id]) {\n            references.push(\n              '<a href=\"#' +\n                clobberPrefix +\n                'fnref-' +\n                safeId +\n                (referenceIndex > 1 ? '-' + referenceIndex : '') +\n                '\" data-footnote-backref=\"\" aria-label=\"' +\n                this.encode(\n                  typeof backLabel === 'string'\n                    ? backLabel\n                    : backLabel(index, referenceIndex)\n                ) +\n                '\" class=\"data-footnote-backref\">' +\n                (referenceIndex > 1\n                  ? '<sup>' + referenceIndex + '</sup>'\n                  : '') +\n                '</a>'\n            )\n          }\n          const reference = references.join(' ')\n          let injected = false\n          this.lineEndingIfNeeded()\n          this.tag('<li id=\"' + clobberPrefix + 'fn-' + safeId + '\">')\n          this.lineEndingIfNeeded()\n          this.tag(\n            definitions[id].replace(\n              /<\\/p>(?:\\r?\\n|\\r)?$/,\n              (/** @type {string} */ $0) => {\n                injected = true\n                return ' ' + reference + $0\n              }\n            )\n          )\n          if (!injected) {\n            this.lineEndingIfNeeded()\n            this.tag(reference)\n          }\n          this.lineEndingIfNeeded()\n          this.tag('</li>')\n        }\n        if (calls.length > 0) {\n          this.lineEndingIfNeeded()\n          this.tag('</ol>')\n          this.lineEndingIfNeeded()\n          this.tag('</section>')\n        }\n      }\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde.\n *\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\n\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {}\n  let single = options_.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  }\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }\n\n            // Opening.\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n            const insideSpan = context.parser.constructs.insideSpan.null\n            if (insideSpan) {\n              // Between.\n              splice(\n                nextEvents,\n                nextEvents.length,\n                0,\n                // @ts-expect-error: to do: update `mdast-util-types` to allow explicit `undefined`s.\n                resolveAll(insideSpan, events.slice(open + 1, index), context)\n              )\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n            splice(events, open - 1, index - open + 3, nextEvents)\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n    return events\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      if (\n        previous === 126 &&\n        events[events.length - 1][1].type !== 'characterEscape'\n      ) {\n        return nok(code)\n      }\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous)\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open = !after || (after === 2 && Boolean(before))\n      token._close = !before || (before === 2 && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n// To do: next major: expose function instead of object.\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions`, to\n * support GFM strikethrough when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmStrikethroughHtml = {\n  enter: {\n    strikethrough() {\n      this.tag('<del>')\n    }\n  },\n  exit: {\n    strikethrough() {\n      this.tag('</del>')\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n}\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {boolean|undefined} */\n\n  let inHead\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n\n  let inRow\n  /** @type {number|undefined} */\n\n  let contentStart\n  /** @type {number|undefined} */\n\n  let contentEnd\n  /** @type {number|undefined} */\n\n  let cellStart\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        /** @type {Token} */\n\n        const text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error Its fine.\n          contentType: 'text'\n        }\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart !== undefined &&\n      cellStart + (seenCellInRow ? 0 : 1) < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      const cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n      seenCellInRow = true\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Array<Align>} */\n\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n\n  let hasDash\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent') // Cant be space or eols at the start of a construct, so were in a cell.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n  /** @type {State} */\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n  /** @type {State} */\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    } // Anything else.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    const originalInterrupt = self.interrupt\n    self.interrupt = true\n    return effects.attempt(\n      {\n        tokenize: tokenizeRowEnd,\n        partial: true\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        effects.enter('tableDelimiterRow')\n        return atDelimiterRowBreak(code)\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        return nok(code)\n      }\n    )(code)\n  }\n  /** @type {State} */\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push('none')\n      return inFillerDelimiter\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    } // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    } // Anything else is not ok.\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    } // `|`\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow') // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, bodyStart, 'linePrefix', 4),\n        tableClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n  /** @type {State} */\n\n  function rowStartBody(code) {\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent') // Cant be space or eols at the start of a construct, so were in a cell.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n  /** @type {State} */\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    } // `|`\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n  /** @type {State} */\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    } // Anything else.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, rowStartBody, 'linePrefix', 4),\n        tableBodyClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, prefixed, 'linePrefix')\n    }\n    /** @type {State} */\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (\n        self.parser.lazy[self.now().line] ||\n        code === null ||\n        markdownLineEnding(code)\n      ) {\n        return nok(code)\n      }\n\n      const tail = self.events[self.events.length - 1] // Indented code can interrupt delimiter and body rows.\n\n      if (\n        !self.parser.constructs.disable.null.includes('codeIndented') &&\n        tail &&\n        tail[1].type === 'linePrefix' &&\n        tail[2].sliceSerialize(tail[1], true).length >= 4\n      ) {\n        return nok(code)\n      }\n\n      self._gfmTableDynamicInterruptHack = true\n      return effects.check(\n        self.parser.constructs.flow,\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return nok(code)\n        },\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return ok(code)\n        }\n      )(code)\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we dont care about tokens, but we open a bogus one\n    // so were valid.\n    effects.enter('check') // EOL.\n\n    effects.consume(code)\n    return whitespace\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    } // EOF or whitespace\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    } // Anything else.\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('./syntax.js').Align} Align\n */\nconst alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n}\n/** @type {HtmlExtension} */\n\nexport const gfmTableHtml = {\n  enter: {\n    table(token) {\n      /** @type {Array<Align>} */\n      // @ts-expect-error Custom.\n      const tableAlign = token._align\n      this.lineEndingIfNeeded()\n      this.tag('<table>')\n      this.setData('tableAlign', tableAlign)\n    },\n\n    tableBody() {\n      // Clear slurping line ending from the delimiter row.\n      this.setData('slurpOneLineEnding')\n      this.tag('<tbody>')\n    },\n\n    tableData() {\n      const tableAlign =\n        /** @type {Array<Align>} */\n        this.getData('tableAlign')\n      const tableColumn =\n        /** @type {number} */\n        this.getData('tableColumn')\n      const align = alignment[tableAlign[tableColumn]]\n\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer()\n      } else {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + align + '>')\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('<thead>')\n    },\n\n    tableHeader() {\n      const tableAlign =\n        /** @type {Array<Align>} */\n        this.getData('tableAlign')\n      const tableColumn =\n        /** @type {number} */\n        this.getData('tableColumn')\n      const align = alignment[tableAlign[tableColumn]]\n      this.lineEndingIfNeeded()\n      this.tag('<th' + align + '>')\n    },\n\n    tableRow() {\n      this.setData('tableColumn', 0)\n      this.lineEndingIfNeeded()\n      this.tag('<tr>')\n    }\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token)\n\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace)\n      }\n\n      this.raw(this.encode(value))\n    },\n\n    table() {\n      this.setData('tableAlign') // If there was no table body, make sure the slurping from the delimiter row\n      // is cleared.\n\n      this.setData('slurpAllLineEndings')\n      this.lineEndingIfNeeded()\n      this.tag('</table>')\n    },\n\n    tableBody() {\n      this.lineEndingIfNeeded()\n      this.tag('</tbody>')\n    },\n\n    tableData() {\n      const tableAlign =\n        /** @type {Array<Align>} */\n        this.getData('tableAlign')\n      const tableColumn =\n        /** @type {number} */\n        this.getData('tableColumn')\n\n      if (tableColumn in tableAlign) {\n        this.tag('</td>')\n        this.setData('tableColumn', tableColumn + 1)\n      } else {\n        // Stop capturing.\n        this.resume()\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('</thead>')\n      this.setData('slurpOneLineEnding', true) // Slurp the line ending from the delimiter row.\n    },\n\n    tableHeader() {\n      const tableColumn =\n        /** @type {number} */\n        this.getData('tableColumn')\n      this.tag('</th>')\n      this.setData('tableColumn', tableColumn + 1)\n    },\n\n    tableRow() {\n      const tableAlign =\n        /** @type {Array<Align>} */\n        this.getData('tableAlign')\n      let tableColumn =\n        /** @type {number} */\n        this.getData('tableColumn')\n\n      while (tableColumn < tableAlign.length) {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>')\n        tableColumn++\n      }\n\n      this.setData('tableColumn', tableColumn)\n      this.lineEndingIfNeeded()\n      this.tag('</tr>')\n    }\n  }\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes dont (but cant escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n","/**\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n// An opening or closing tag start, followed by a case-insensitive specific tag name,\n// followed by HTML whitespace, a greater than, or a slash.\nconst reFlow =\n  /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi\n\n// As HTML (text) parses tags separately (and very strictly), we dont need to be\n// global.\nconst reText = new RegExp('^' + reFlow.source, 'i')\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions`, to\n * support GitHubs weird and useless tagfilter when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmTagfilterHtml = {\n  exit: {\n    htmlFlowData(token) {\n      exitHtmlData.call(this, token, reFlow)\n    },\n    htmlTextData(token) {\n      exitHtmlData.call(this, token, reText)\n    }\n  }\n}\n\n/**\n * @this {CompileContext}\n * @param {Token} token\n * @param {RegExp} filter\n */\nfunction exitHtmlData(token, filter) {\n  let value = this.sliceSerialize(token)\n\n  if (this.options.allowDangerousHtml) {\n    value = value.replace(filter, '&lt;$1$2')\n  }\n\n  this.raw(this.encode(value))\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  markdownSpace\n} from 'micromark-util-character'\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}\n\n// To do: next major: expose function to make extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions`, to\n * enable GFM task list items syntax.\n *\n * @type {Extension}\n */\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n  return open\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n      // Exit if theres stuff before.\n      self.previous !== null ||\n      // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n    return nok(code)\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code)\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check(\n        {\n          tokenize: spaceThenNonSpace\n        },\n        ok,\n        nok\n      )(code)\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, 'whitespace')\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means theres content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n// To do: next major: expose function to make extension.\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions` to\n * support GFM task list items when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmTaskListItemHtml = {\n  enter: {\n    taskListCheck() {\n      this.tag('<input type=\"checkbox\" disabled=\"\" ')\n    }\n  },\n  exit: {\n    taskListCheck() {\n      this.tag('/>')\n    },\n    taskListCheckValueChecked() {\n      this.tag('checked=\"\" ')\n    }\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * @typedef {import('mdast-util-gfm-table').Options} Options\n *   Configuration.\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown,\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown,\n    gfmTableFromMarkdown,\n    gfmTaskListItemFromMarkdown\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown,\n      gfmFootnoteToMarkdown(),\n      gfmStrikethroughToMarkdown,\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown\n    ]\n  }\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction\n * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject\n */\n\nimport {ccount} from 'ccount'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n// To do: next major: expose functions instead of extensions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM autolink literals.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmAutolinkLiteralFromMarkdown = {\n  transforms: [transformGfmAutolinkLiterals],\n  enter: {\n    literalAutolink: enterLiteralAutolink,\n    literalAutolinkEmail: enterLiteralAutolinkValue,\n    literalAutolinkHttp: enterLiteralAutolinkValue,\n    literalAutolinkWww: enterLiteralAutolinkValue\n  },\n  exit: {\n    literalAutolink: exitLiteralAutolink,\n    literalAutolinkEmail: exitLiteralAutolinkEmail,\n    literalAutolinkHttp: exitLiteralAutolinkHttp,\n    literalAutolinkWww: exitLiteralAutolinkWww\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmAutolinkLiteralToMarkdown = {\n  unsafe: [\n    {\n      character: '@',\n      before: '[+\\\\-.\\\\w]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {\n      character: '.',\n      before: '[Ww]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {character: ':', before: '[ps]', after: '\\\\/', inConstruct, notInConstruct}\n  ]\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = /** @type {Link} */ (this.stack[this.stack.length - 1])\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/g, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Link | Array<PhrasingContent> | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    (!email || code !== 47)\n  )\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","/**\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {Extract<Node, MdastParent>} Parent\n * @typedef {Exclude<Parent, Root>} ContentParent\n *\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[Root, ...Array<ContentParent>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`)  whole match\n *   * `...capture` (`Array<string>`)  matches from regex capture groups\n *   * `match` (`RegExpMatchObject`)  info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * or when `false`, do not replace at all\n *   * or when `string`, replace with a text node of that value\n *   * or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {string | RegExp} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\n *   Several find and replaces, in object form.\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n * @typedef {string | ReplaceFunction} Replace\n *   Thing to replace with.\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore.\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param tree\n *   Tree to change.\n * @param find\n *   Patterns to find.\n * @param replace\n *   Things to replace with (when `find` is `Find`) or configuration.\n * @param options\n *   Configuration (when `find` is not `Find`).\n * @returns\n *   Given, modified, tree.\n */\n// To do: next major: remove `find` & `replace` combo, remove schema.\nexport const findAndReplace =\n  /**\n   * @type {(\n   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &\n   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)\n   * )}\n   **/\n  (\n    /**\n     * @template {Node} Tree\n     * @param {Tree} tree\n     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\n     * @param {Replace | Options | null | undefined} [replace]\n     * @param {Options | null | undefined} [options]\n     * @returns {Tree}\n     */\n    function (tree, find, replace, options) {\n      /** @type {Options | null | undefined} */\n      let settings\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n      let schema\n\n      if (typeof find === 'string' || find instanceof RegExp) {\n        // @ts-expect-error dont expect options twice.\n        schema = [[find, replace]]\n        settings = options\n      } else {\n        schema = find\n        // @ts-expect-error dont expect replace twice.\n        settings = replace\n      }\n\n      if (!settings) {\n        settings = {}\n      }\n\n      const ignored = convert(settings.ignore || [])\n      const pairs = toPairs(schema)\n      let pairIndex = -1\n\n      while (++pairIndex < pairs.length) {\n        visitParents(tree, 'text', visitor)\n      }\n\n      // To do next major: dont return the given tree.\n      return tree\n\n      /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */\n      function visitor(node, parents) {\n        let index = -1\n        /** @type {Parent | undefined} */\n        let grandparent\n\n        while (++index < parents.length) {\n          const parent = parents[index]\n\n          if (\n            ignored(\n              parent,\n              // @ts-expect-error: TS doesnt understand but its perfect.\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\n              grandparent\n            )\n          ) {\n            return\n          }\n\n          grandparent = parent\n        }\n\n        if (grandparent) {\n          return handler(node, parents)\n        }\n      }\n\n      /**\n       * Handle a text node which is not in an ignored parent.\n       *\n       * @param {Text} node\n       *   Text node.\n       * @param {Array<Parent>} parents\n       *   Parents.\n       * @returns {VisitorResult}\n       *   Result.\n       */\n      function handler(node, parents) {\n        const parent = parents[parents.length - 1]\n        const find = pairs[pairIndex][0]\n        const replace = pairs[pairIndex][1]\n        let start = 0\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        const index = parent.children.indexOf(node)\n        let change = false\n        /** @type {Array<PhrasingContent>} */\n        let nodes = []\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          const position = match.index\n          /** @type {RegExpMatchObject} */\n          const matchObject = {\n            index: match.index,\n            input: match.input,\n            // @ts-expect-error: stack is fine.\n            stack: [...parents, node]\n          }\n          let value = replace(...match, matchObject)\n\n          if (typeof value === 'string') {\n            value = value.length > 0 ? {type: 'text', value} : undefined\n          }\n\n          // It wasnt a match after all.\n          if (value !== false) {\n            if (start !== position) {\n              nodes.push({\n                type: 'text',\n                value: node.value.slice(start, position)\n              })\n            }\n\n            if (Array.isArray(value)) {\n              nodes.push(...value)\n            } else if (value) {\n              nodes.push(value)\n            }\n\n            start = position + match[0].length\n            change = true\n          }\n\n          if (!find.global) {\n            break\n          }\n\n          match = find.exec(node.value)\n        }\n\n        if (change) {\n          if (start < node.value.length) {\n            nodes.push({type: 'text', value: node.value.slice(start)})\n          }\n\n          parent.children.splice(index, 1, ...nodes)\n        } else {\n          nodes = [node]\n        }\n\n        return index + nodes.length\n      }\n    }\n  )\n\n/**\n * Turn a schema into pairs.\n *\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema')\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    /** @type {string} */\n    let key\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])])\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace\n}\n","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodes children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The nodes position in its parent.\n * @param parent\n *   The nodes parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youre going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return '\\u001B[33m' + d + '\\u001B[39m'\n}\n","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {association} from 'mdast-util-to-markdown/lib/util/association.js'\nimport {containerFlow} from 'mdast-util-to-markdown/lib/util/container-flow.js'\nimport {indentLines} from 'mdast-util-to-markdown/lib/util/indent-lines.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\nfootnoteReference.peek = footnoteReferencePeek\n\n// To do: next major: rename `context` -> `state`, `safeOptions` to `info`, use\n// utilities on `state`.\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteDefinition: enterFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteCallString: enterFootnoteCallString\n    },\n    exit: {\n      gfmFootnoteDefinition: exitFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteCallString: exitFootnoteCallString\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function gfmFootnoteToMarkdown() {\n  return {\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnoteDefinition, footnoteReference}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteReference')\n  const subexit = context.enter('reference')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteDefinition} node\n */\nfunction footnoteDefinition(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteDefinition')\n  const subexit = context.enter('label')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  value += tracker.move(\n    ']:' + (node.children && node.children.length > 0 ? ' ' : '')\n  )\n  tracker.shift(4)\n  value += tracker.move(\n    indentLines(containerFlow(node, context, tracker.current()), map)\n  )\n  exit()\n\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, index, blank) {\n  if (index === 0) {\n    return line\n  }\n\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references dont work in this\n * matching: `&copy;` does not match ``, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how were going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What constructs we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: expose functions.\n// To do: next major: use `state`, state utilities.\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {strikethrough: enterStrikethrough},\n  exit: {strikethrough: exitStrikethrough}\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmStrikethroughToMarkdown = {\n  unsafe: [\n    {\n      character: '~',\n      inConstruct: 'phrasing',\n      notInConstruct: constructsWithoutStrikethrough\n    }\n  ],\n  handlers: {delete: handleDelete}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  const exit = context.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += containerPhrasing(node, context, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, its actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, its actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When wed serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we cant escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n *\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells.\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters.\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {inlineCode} from 'mdast-util-to-markdown/lib/handle/inline-code.js'\nimport {markdownTable} from 'markdown-table'\n\n// To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.\n// To do: next major: use `defaultHandlers.inlineCode`.\n// To do: next major: expose functions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM tables.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  /** @type {Array<'left' | 'right' | 'center' | 'none'>} */\n  // @ts-expect-error: `align` is custom.\n  const align = token._align\n  this.enter(\n    {\n      type: 'table',\n      align: align.map((d) => (d === 'none' ? null : d)),\n      children: []\n    },\n    token\n  )\n  this.setData('inTable', true)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.setData('inTable')\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1])\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes dont (but cant escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, context, safeOptions) {\n    return serializeData(\n      handleTableAsData(node, context, safeOptions),\n      node.align\n    )\n  }\n\n  /**\n   * This function isnt really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, context, safeOptions) {\n    const row = handleTableRowAsData(node, context, safeOptions)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, context, safeOptions) {\n    const exit = context.enter('tableCell')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...safeOptions,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = context.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(\n        children[index],\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableRowAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = context.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(\n        children[index],\n        node,\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, context) {\n    let value = inlineCode(node, parent, context)\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef Options\n *   Configuration (optional).\n * @property {string|null|ReadonlyArray<string|null|undefined>} [align]\n *   One style for all columns, or styles for their respective columns.\n *   Each style is either `'l'` (left), `'r'` (right), or `'c'` (center).\n *   Other values are treated as `''`, which doesnt place the colon in the\n *   alignment row but does align left.\n *   *Only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean} [padding=true]\n *   Whether to add a space of padding between delimiters and cells.\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {boolean} [delimiterStart=true]\n *   Whether to begin each row with the delimiter.\n *\n *   >  **Note**: please dont use this: it could create fragile structures\n *   > that arent understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean} [delimiterEnd=true]\n *   Whether to end each row with the delimiter.\n *\n *   >  **Note**: please dont use this: it could create fragile structures\n *   > that arent understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean} [alignDelimiters=true]\n *   Whether to align the delimiters.\n *   By default, they are aligned:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {(value: string) => number} [stringLength]\n *   Function to detect the length of table cell content.\n *   This is used when aligning the delimiters (`|`) between table cells.\n *   Full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source.\n *   To fix this, you can pass this function, which receives the cell content\n *   and returns its visible size.\n *   Note that what is and isnt visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['', 'Charlie'],\n *     ['', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   |  | Charlie |\n *   |  | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['', 'Charlie'],\n *       ['', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   |   | Charlie |\n *   |     | Delta   |\n *   ```\n */\n\n/**\n * @typedef {Options} MarkdownTableOptions\n * @todo\n *   Remove next major.\n */\n\n/**\n * Generate a markdown ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables)) table..\n *\n * @param {ReadonlyArray<ReadonlyArray<string|null|undefined>>} table\n *   Table data (matrix of strings).\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n */\nexport function markdownTable(table, options = {}) {\n  const align = (options.align || []).concat()\n  const stringLength = options.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we dont align delimiters, but otherwise wed\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (options.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      options.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (options.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (options.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (options.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        options.padding !== false &&\n        // Dont add the opening space if were not aligning and the cell is\n        // empty: there will be a closing space.\n        !(options.alignDelimiters === false && cell === '') &&\n        (options.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (options.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (options.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (options.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        options.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      options.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string|null|undefined} [value]\n * @returns {string}\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string} value\n * @returns {number}\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * @param {string|null|undefined} value\n * @returns {number}\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n    ? 108 /* `l` */\n    : code === 82 /* `R` */ || code === 114 /* `r` */\n    ? 114 /* `r` */\n    : 0\n}\n","/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\n/**\n * @typedef {Extract<Root | Content, Parent>} Parents\n */\n\nimport {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use\n// `track` from `state`.\n// To do: next major: replace exports with functions.\n// To do: next major: use `defaulthandlers.listItem`.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM task list items.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM task list items.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmTaskListItemToMarkdown = {\n  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n  handlers: {listItem: listItemWithTaskListItem}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])\n  // Were always in a paragraph, in a list item.\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2])\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = track(safeOptions)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = listItem(node, parent, context, {\n    ...safeOptions,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","import remarkStringify from './lib/index.js'\n\nexport default remarkStringify\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/** @type {import('unified').Plugin<[Options]|void[], Node, string>} */\nexport default function remarkStringify(options) {\n  /** @type {import('unified').CompilerFunction<Node, string>} */\n  const compiler = (tree) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return toMarkdown(\n      tree,\n      Object.assign({}, settings, options, {\n        // Note: this option is not in the readme.\n        // The goal is for it to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions:\n          /** @type {ToMarkdownOptions['extensions']} */ (\n            this.data('toMarkdownExtensions')\n          ) || []\n      })\n    )\n  }\n\n  Object.assign(this, {Compiler: compiler})\n}\n","/**\n * @typedef {import('./types.js').Enter} Enter\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').FlowContent} FlowContent\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').PhrasingContent} PhrasingContent\n * @typedef {import('./types.js').SafeConfig} SafeConfig\n * @typedef {import('./types.js').State} State\n * @typedef {import('./types.js').TrackFields} TrackFields\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Node} tree\n *   Tree to serialize.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {State} */\n  const state = {\n    enter,\n    indentLines,\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    safe: safeBound,\n    stack: [],\n    unsafe: [],\n    join: [],\n    // @ts-expect-error: well fill it next.\n    handlers: {},\n    options: {},\n    indexStack: [],\n    // @ts-expect-error: well add `handle` later.\n    handle: undefined\n  }\n\n  configure(state, {unsafe, join, handlers})\n  configure(state, options)\n\n  if (state.options.tightDefinitions) {\n    configure(state, {join: [joinDefinition]})\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} node\n * @returns {never}\n */\nfunction unknown(node) {\n  // @ts-expect-error: fine.\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What constructs we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n","/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and its value is this functions\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but its set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesnt have a `key` property, the special\n   * invalid handler will be called.\n   * If `value` has an unknown `key`, the special unknown handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and its result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but its set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n","/**\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').State} State\n */\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      /* c8 ignore next 2 */\n      // @ts-expect-error: hush.\n      base[key] = [...(base[key] || []), ...(extension[key] || [])]\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      // @ts-expect-error: hush.\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we cant put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    !state.options.fences &&\n      node.value &&\n      // If theres no info\n      !node.lang &&\n      // And theres a non-whitespace character\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesnt start or end in a blank\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If theres no url, or\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot form depending on the\n// previous or next character of sequences.\n// Theres no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Emphasis} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').State} State\n */\n\nimport {visit, EXIT} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, (node) => {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","/**\n * @typedef {import('mdast').HTML} HTML\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {HTML} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that were in phrasing, because escapes dont work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').State} State\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If theres a url\n      node.url &&\n      // And theres a no title\n      !node.title &&\n      // And the content of `node` is a single text node\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesnt contain ASCII control codes (character escapes and\n      // references dont work), space, or angle brackets\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkBulletOrderedOther} from '../util/check-bullet-ordered-other.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? checkBulletOrderedOther(state)\n    : checkBulletOther(state)\n  const bulletLastUsed = state.bulletLastUsed\n  let useDifferentMarker = false\n\n  if (\n    parent &&\n    // Explicit `other` set.\n    (node.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther) &&\n    bulletLastUsed &&\n    bullet === bulletLastUsed\n  ) {\n    useDifferentMarker = true\n  }\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If theres an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If theres a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBulletOrdered} from './check-bullet-ordered.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrderedOther(state) {\n  const bulletOrdered = checkBulletOrdered(state)\n  const bulletOrderedOther = state.options.bulletOrderedOther\n\n  if (!bulletOrderedOther) {\n    return bulletOrdered === '.' ? ')' : '.'\n  }\n\n  if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOrderedOther +\n        '` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOrderedOther === bulletOrdered) {\n    throw new Error(\n      'Expected `bulletOrdered` (`' +\n        bulletOrdered +\n        '`) and `bulletOrderedOther` (`' +\n        bulletOrderedOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOrderedOther\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some((d) => phrasing(d))\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  // @ts-expect-error: `root`s are supposed to have one type of content\n  return fn.call(state, node, info)\n}\n","/**\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * @param\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\nexport const phrasing = /** @type {AssertPredicatePhrasing} */ (\n  convert([\n    'break',\n    'delete',\n    'emphasis',\n    'footnote',\n    'footnoteReference',\n    'image',\n    'imageReference',\n    'inlineCode',\n    'link',\n    'linkReference',\n    'strong',\n    'text'\n  ])\n)\n","/**\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkStrong} from '../util/check-strong.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot form depending on the\n// previous or next character of sequences.\n// Theres no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Strong} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Strong} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Text} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @typedef {import('./types.js').Join} Join\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Two lists with the same marker.\n  if (\n    left.type === 'list' &&\n    left.type === right.type &&\n    Boolean(left.ordered) === Boolean(right.ordered) &&\n    !(left.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther)\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @typedef {import('./types.js').Unsafe} Unsafe\n * @typedef {import('./types.js').ConstructName} ConstructName\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","import { toc as makeToc } from 'mdast-util-toc';\nimport { u as buildNode } from 'unist-builder';\n\nimport findTocStart from './findTocStart.js';\nimport parseTocConfiguration from './parseTocConfiguration.js';\n\nimport isInRange from '../../isInRange.js';\nimport { DEFAULT_TOC_OPTIONS } from '../../constants.js';\n\nconst transformer = (tree, file) => {\n  const tocStartFinder = findTocStart(tree);\n\n  if (!tocStartFinder.tocStart) {\n    file.info('No ToC start found, only simple formatting was done');\n    return;\n  }\n\n  const tocConfiguration = {\n    ...DEFAULT_TOC_OPTIONS,\n    ...parseTocConfiguration(tocStartFinder.tocStart.value),\n  };\n\n  const filteredHeadings = tree.children.filter(\n    (part) => part.type === 'heading' && isInRange(part.depth, tocConfiguration),\n  );\n\n  const toc = makeToc(buildNode('root', filteredHeadings)).map;\n  tree.children.splice(tocStartFinder.tocStartIndex + 1, tocStartFinder.tocSize, toc);\n};\n\nexport default () => transformer;\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').List} List\n * @typedef {import('./search.js').SearchOptions} SearchOptions\n * @typedef {import('./contents.js').ContentsOptions} ContentsOptions\n */\n\n/**\n * @typedef {Root | Content} Node\n * @typedef {SearchOptions & ContentsOptions & ExtraOptions} Options\n *\n * @typedef ExtraOptions\n *   Extra configuration fields.\n * @property {string | null | undefined} [heading]\n *   Heading to look for, wrapped in `new RegExp('^(' + value + ')$', 'i')`.\n *\n * @typedef Result\n *   Results.\n * @property {number | null} index\n *   Index of the node right after the table of contents heading, `-1` if no\n *   heading was found, `null` if no `heading` was given.\n * @property {number | null} endIndex\n *   Index of the first node after `heading` that is not part of its section,\n *   `-1` if no heading was found, `null` if no `heading` was given, same as\n *   `index` if there are no nodes between `heading` and the first heading in\n *   the table of contents.\n * @property {List | null} map\n *   List representing the generated table of contents, `null` if no table of\n *   contents could be created, either because no heading was found or because\n *   no following headings were found.\n */\n\nimport {search} from './search.js'\nimport {contents} from './contents.js'\nimport {toExpression} from './to-expression.js'\n\n/**\n * Generate a table of contents from `tree`.\n *\n * Looks for the first heading matching `options.heading` (case insensitive) and\n * returns a table of contents (a list) for all following headings.\n * If no `heading` is specified, creates a table of contents for all headings in\n * `tree`.\n * `tree` is not changed.\n *\n * Links in the list to headings are based on GitHubs style.\n * Only top-level headings (those not in blockquotes or lists), are used.\n * This default behavior can be changed by passing `options.parents`.\n *\n * @param {Node} tree\n *   Tree to search and generate from.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Result}\n *   Results.\n */\nexport function toc(tree, options) {\n  const settings = options || {}\n  const heading = settings.heading ? toExpression(settings.heading) : undefined\n  const result = search(tree, heading, settings)\n\n  return {\n    index: heading ? result.index : null,\n    endIndex: heading ? result.endIndex : null,\n    map: result.map.length > 0 ? contents(result.map, settings) : null\n  }\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {Root | Content} Node\n * @typedef {Heading['depth']} Rank\n *\n */\n\n/**\n * @typedef SearchOptions\n *   Search configuration.\n * @property {Rank | null | undefined} [maxDepth=6]\n *   Maximum heading depth to include in the table of contents.\n *\n *   This is inclusive: when set to `3`, level three headings are included\n *   (those with three hashes, `###`).\n * @property {string | null | undefined} [skip]\n *   Headings to skip, wrapped in `new RegExp('^(' + value + ')$', 'i')`.\n *\n *   Any heading matching this expression will not be present in the table of\n *   contents.\n * @property {Test} [parents]\n *   Allow headings to be children of certain node types (default: the to `toc`\n *   given `tree`, to only allow top-level headings).\n *\n *   Internally, uses `unist-util-is` to check, so `parents` can be any\n *   `is`-compatible test.\n *\n * @typedef SearchEntry\n *   Entry.\n * @property {string} id\n *   ID of entry.\n * @property {Array<PhrasingContent>} children\n *   Contents of entry.\n * @property {Rank} depth\n *   Rank of entry.\n *\n * @typedef SearchResult\n *   Results.\n * @property {number} index\n *   Where the contents section starts, if looking for a heading.\n * @property {number} endIndex\n *   Where the contents section ends, if looking for a heading.\n * @property {Array<SearchEntry>} map\n *   List of entries.\n */\n\nimport Slugger from 'github-slugger'\nimport {toString} from 'mdast-util-to-string'\nimport {visit} from 'unist-util-visit'\nimport {convert} from 'unist-util-is'\nimport {toExpression} from './to-expression.js'\n\nconst slugs = new Slugger()\n\n/**\n * Search a node for a toc.\n *\n * @param {Node} root\n * @param {RegExp | undefined} expression\n * @param {SearchOptions} settings\n * @returns {SearchResult}\n */\nexport function search(root, expression, settings) {\n  const skip = settings.skip ? toExpression(settings.skip) : undefined\n  const parents = convert(settings.parents || ((d) => d === root))\n  /** @type {Array<SearchEntry>} */\n  const map = []\n  /** @type {number | undefined} */\n  let index\n  /** @type {number | undefined} */\n  let endIndex\n  /** @type {Heading | undefined} */\n  let opening\n\n  slugs.reset()\n\n  // Visit all headings in `root`.  We `slug` all headings (to account for\n  // duplicates), but only create a TOC from top-level headings (by default).\n  visit(root, 'heading', (node, position, parent) => {\n    const value = toString(node, {includeImageAlt: false})\n    /** @type {string} */\n    // @ts-expect-error `hProperties` from <https://github.com/syntax-tree/mdast-util-to-hast>\n    const id = node.data && node.data.hProperties && node.data.hProperties.id\n    const slug = slugs.slug(id || value)\n\n    if (!parents(parent)) {\n      return\n    }\n\n    // Our opening heading.\n    if (position !== null && expression && !index && expression.test(value)) {\n      index = position + 1\n      opening = node\n      return\n    }\n\n    // Our closing heading.\n    if (\n      position !== null &&\n      opening &&\n      !endIndex &&\n      node.depth <= opening.depth\n    ) {\n      endIndex = position\n    }\n\n    // A heading after the closing (if we were looking for one).\n    if (\n      (endIndex || !expression) &&\n      (!settings.maxDepth || node.depth <= settings.maxDepth) &&\n      (!skip || !skip.test(value))\n    ) {\n      map.push({depth: node.depth, children: node.children, id: slug})\n    }\n  })\n\n  return {\n    index: index === undefined ? -1 : index,\n    // <sindresorhus/eslint-plugin-unicorn#980>\n    // @ts-expect-error Looks like a parent.\n    endIndex: index === undefined ? -1 : endIndex || root.children.length, // eslint-disable-line unicorn/explicit-length-check\n    map\n  }\n}\n","import { regex } from './regex.js'\n\nconst own = Object.hasOwnProperty\n\n/**\n * Slugger.\n */\nexport default class BananaSlug {\n  /**\n   * Create a new slug class.\n   */\n  constructor () {\n    /** @type {Record<string, number>} */\n    // eslint-disable-next-line no-unused-expressions\n    this.occurrences\n\n    this.reset()\n  }\n\n  /**\n   * Generate a unique slug.\n  *\n  * Tracks previously generated slugs: repeated calls with the same value\n  * will result in different slugs.\n  * Use the `slug` function to get same slugs.\n   *\n   * @param  {string} value\n   *   String of text to slugify\n   * @param  {boolean} [maintainCase=false]\n   *   Keep the current case, otherwise make all lowercase\n   * @return {string}\n   *   A unique slug string\n   */\n  slug (value, maintainCase) {\n    const self = this\n    let result = slug(value, maintainCase === true)\n    const originalSlug = result\n\n    while (own.call(self.occurrences, result)) {\n      self.occurrences[originalSlug]++\n      result = originalSlug + '-' + self.occurrences[originalSlug]\n    }\n\n    self.occurrences[result] = 0\n\n    return result\n  }\n\n  /**\n   * Reset - Forget all previous slugs\n   *\n   * @return void\n   */\n  reset () {\n    this.occurrences = Object.create(null)\n  }\n}\n\n/**\n * Generate a slug.\n *\n * Does not track previously generated slugs: repeated calls with the same value\n * will result in the exact same slug.\n * Use the `GithubSlugger` class to get unique slugs.\n *\n * @param  {string} value\n *   String of text to slugify\n * @param  {boolean} [maintainCase=false]\n *   Keep the current case, otherwise make all lowercase\n * @return {string}\n *   A unique slug string\n */\nexport function slug (value, maintainCase) {\n  if (typeof value !== 'string') return ''\n  if (!maintainCase) value = value.toLowerCase()\n  return value.replace(regex, '').replace(/ /g, '-')\n}\n","// This module is generated by `script/`.\n/* eslint-disable no-control-regex, no-misleading-character-class, no-useless-escape */\nexport const regex = /[\\0-\\x1F!-,\\.\\/:-@\\[-\\^`\\{-\\xA9\\xAB-\\xB4\\xB6-\\xB9\\xBB-\\xBF\\xD7\\xF7\\u02C2-\\u02C5\\u02D2-\\u02DF\\u02E5-\\u02EB\\u02ED\\u02EF-\\u02FF\\u0375\\u0378\\u0379\\u037E\\u0380-\\u0385\\u0387\\u038B\\u038D\\u03A2\\u03F6\\u0482\\u0530\\u0557\\u0558\\u055A-\\u055F\\u0589-\\u0590\\u05BE\\u05C0\\u05C3\\u05C6\\u05C8-\\u05CF\\u05EB-\\u05EE\\u05F3-\\u060F\\u061B-\\u061F\\u066A-\\u066D\\u06D4\\u06DD\\u06DE\\u06E9\\u06FD\\u06FE\\u0700-\\u070F\\u074B\\u074C\\u07B2-\\u07BF\\u07F6-\\u07F9\\u07FB\\u07FC\\u07FE\\u07FF\\u082E-\\u083F\\u085C-\\u085F\\u086B-\\u089F\\u08B5\\u08C8-\\u08D2\\u08E2\\u0964\\u0965\\u0970\\u0984\\u098D\\u098E\\u0991\\u0992\\u09A9\\u09B1\\u09B3-\\u09B5\\u09BA\\u09BB\\u09C5\\u09C6\\u09C9\\u09CA\\u09CF-\\u09D6\\u09D8-\\u09DB\\u09DE\\u09E4\\u09E5\\u09F2-\\u09FB\\u09FD\\u09FF\\u0A00\\u0A04\\u0A0B-\\u0A0E\\u0A11\\u0A12\\u0A29\\u0A31\\u0A34\\u0A37\\u0A3A\\u0A3B\\u0A3D\\u0A43-\\u0A46\\u0A49\\u0A4A\\u0A4E-\\u0A50\\u0A52-\\u0A58\\u0A5D\\u0A5F-\\u0A65\\u0A76-\\u0A80\\u0A84\\u0A8E\\u0A92\\u0AA9\\u0AB1\\u0AB4\\u0ABA\\u0ABB\\u0AC6\\u0ACA\\u0ACE\\u0ACF\\u0AD1-\\u0ADF\\u0AE4\\u0AE5\\u0AF0-\\u0AF8\\u0B00\\u0B04\\u0B0D\\u0B0E\\u0B11\\u0B12\\u0B29\\u0B31\\u0B34\\u0B3A\\u0B3B\\u0B45\\u0B46\\u0B49\\u0B4A\\u0B4E-\\u0B54\\u0B58-\\u0B5B\\u0B5E\\u0B64\\u0B65\\u0B70\\u0B72-\\u0B81\\u0B84\\u0B8B-\\u0B8D\\u0B91\\u0B96-\\u0B98\\u0B9B\\u0B9D\\u0BA0-\\u0BA2\\u0BA5-\\u0BA7\\u0BAB-\\u0BAD\\u0BBA-\\u0BBD\\u0BC3-\\u0BC5\\u0BC9\\u0BCE\\u0BCF\\u0BD1-\\u0BD6\\u0BD8-\\u0BE5\\u0BF0-\\u0BFF\\u0C0D\\u0C11\\u0C29\\u0C3A-\\u0C3C\\u0C45\\u0C49\\u0C4E-\\u0C54\\u0C57\\u0C5B-\\u0C5F\\u0C64\\u0C65\\u0C70-\\u0C7F\\u0C84\\u0C8D\\u0C91\\u0CA9\\u0CB4\\u0CBA\\u0CBB\\u0CC5\\u0CC9\\u0CCE-\\u0CD4\\u0CD7-\\u0CDD\\u0CDF\\u0CE4\\u0CE5\\u0CF0\\u0CF3-\\u0CFF\\u0D0D\\u0D11\\u0D45\\u0D49\\u0D4F-\\u0D53\\u0D58-\\u0D5E\\u0D64\\u0D65\\u0D70-\\u0D79\\u0D80\\u0D84\\u0D97-\\u0D99\\u0DB2\\u0DBC\\u0DBE\\u0DBF\\u0DC7-\\u0DC9\\u0DCB-\\u0DCE\\u0DD5\\u0DD7\\u0DE0-\\u0DE5\\u0DF0\\u0DF1\\u0DF4-\\u0E00\\u0E3B-\\u0E3F\\u0E4F\\u0E5A-\\u0E80\\u0E83\\u0E85\\u0E8B\\u0EA4\\u0EA6\\u0EBE\\u0EBF\\u0EC5\\u0EC7\\u0ECE\\u0ECF\\u0EDA\\u0EDB\\u0EE0-\\u0EFF\\u0F01-\\u0F17\\u0F1A-\\u0F1F\\u0F2A-\\u0F34\\u0F36\\u0F38\\u0F3A-\\u0F3D\\u0F48\\u0F6D-\\u0F70\\u0F85\\u0F98\\u0FBD-\\u0FC5\\u0FC7-\\u0FFF\\u104A-\\u104F\\u109E\\u109F\\u10C6\\u10C8-\\u10CC\\u10CE\\u10CF\\u10FB\\u1249\\u124E\\u124F\\u1257\\u1259\\u125E\\u125F\\u1289\\u128E\\u128F\\u12B1\\u12B6\\u12B7\\u12BF\\u12C1\\u12C6\\u12C7\\u12D7\\u1311\\u1316\\u1317\\u135B\\u135C\\u1360-\\u137F\\u1390-\\u139F\\u13F6\\u13F7\\u13FE-\\u1400\\u166D\\u166E\\u1680\\u169B-\\u169F\\u16EB-\\u16ED\\u16F9-\\u16FF\\u170D\\u1715-\\u171F\\u1735-\\u173F\\u1754-\\u175F\\u176D\\u1771\\u1774-\\u177F\\u17D4-\\u17D6\\u17D8-\\u17DB\\u17DE\\u17DF\\u17EA-\\u180A\\u180E\\u180F\\u181A-\\u181F\\u1879-\\u187F\\u18AB-\\u18AF\\u18F6-\\u18FF\\u191F\\u192C-\\u192F\\u193C-\\u1945\\u196E\\u196F\\u1975-\\u197F\\u19AC-\\u19AF\\u19CA-\\u19CF\\u19DA-\\u19FF\\u1A1C-\\u1A1F\\u1A5F\\u1A7D\\u1A7E\\u1A8A-\\u1A8F\\u1A9A-\\u1AA6\\u1AA8-\\u1AAF\\u1AC1-\\u1AFF\\u1B4C-\\u1B4F\\u1B5A-\\u1B6A\\u1B74-\\u1B7F\\u1BF4-\\u1BFF\\u1C38-\\u1C3F\\u1C4A-\\u1C4C\\u1C7E\\u1C7F\\u1C89-\\u1C8F\\u1CBB\\u1CBC\\u1CC0-\\u1CCF\\u1CD3\\u1CFB-\\u1CFF\\u1DFA\\u1F16\\u1F17\\u1F1E\\u1F1F\\u1F46\\u1F47\\u1F4E\\u1F4F\\u1F58\\u1F5A\\u1F5C\\u1F5E\\u1F7E\\u1F7F\\u1FB5\\u1FBD\\u1FBF-\\u1FC1\\u1FC5\\u1FCD-\\u1FCF\\u1FD4\\u1FD5\\u1FDC-\\u1FDF\\u1FED-\\u1FF1\\u1FF5\\u1FFD-\\u203E\\u2041-\\u2053\\u2055-\\u2070\\u2072-\\u207E\\u2080-\\u208F\\u209D-\\u20CF\\u20F1-\\u2101\\u2103-\\u2106\\u2108\\u2109\\u2114\\u2116-\\u2118\\u211E-\\u2123\\u2125\\u2127\\u2129\\u212E\\u213A\\u213B\\u2140-\\u2144\\u214A-\\u214D\\u214F-\\u215F\\u2189-\\u24B5\\u24EA-\\u2BFF\\u2C2F\\u2C5F\\u2CE5-\\u2CEA\\u2CF4-\\u2CFF\\u2D26\\u2D28-\\u2D2C\\u2D2E\\u2D2F\\u2D68-\\u2D6E\\u2D70-\\u2D7E\\u2D97-\\u2D9F\\u2DA7\\u2DAF\\u2DB7\\u2DBF\\u2DC7\\u2DCF\\u2DD7\\u2DDF\\u2E00-\\u2E2E\\u2E30-\\u3004\\u3008-\\u3020\\u3030\\u3036\\u3037\\u303D-\\u3040\\u3097\\u3098\\u309B\\u309C\\u30A0\\u30FB\\u3100-\\u3104\\u3130\\u318F-\\u319F\\u31C0-\\u31EF\\u3200-\\u33FF\\u4DC0-\\u4DFF\\u9FFD-\\u9FFF\\uA48D-\\uA4CF\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA62C-\\uA63F\\uA673\\uA67E\\uA6F2-\\uA716\\uA720\\uA721\\uA789\\uA78A\\uA7C0\\uA7C1\\uA7CB-\\uA7F4\\uA828-\\uA82B\\uA82D-\\uA83F\\uA874-\\uA87F\\uA8C6-\\uA8CF\\uA8DA-\\uA8DF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA954-\\uA95F\\uA97D-\\uA97F\\uA9C1-\\uA9CE\\uA9DA-\\uA9DF\\uA9FF\\uAA37-\\uAA3F\\uAA4E\\uAA4F\\uAA5A-\\uAA5F\\uAA77-\\uAA79\\uAAC3-\\uAADA\\uAADE\\uAADF\\uAAF0\\uAAF1\\uAAF7-\\uAB00\\uAB07\\uAB08\\uAB0F\\uAB10\\uAB17-\\uAB1F\\uAB27\\uAB2F\\uAB5B\\uAB6A-\\uAB6F\\uABEB\\uABEE\\uABEF\\uABFA-\\uABFF\\uD7A4-\\uD7AF\\uD7C7-\\uD7CA\\uD7FC-\\uD7FF\\uE000-\\uF8FF\\uFA6E\\uFA6F\\uFADA-\\uFAFF\\uFB07-\\uFB12\\uFB18-\\uFB1C\\uFB29\\uFB37\\uFB3D\\uFB3F\\uFB42\\uFB45\\uFBB2-\\uFBD2\\uFD3E-\\uFD4F\\uFD90\\uFD91\\uFDC8-\\uFDEF\\uFDFC-\\uFDFF\\uFE10-\\uFE1F\\uFE30-\\uFE32\\uFE35-\\uFE4C\\uFE50-\\uFE6F\\uFE75\\uFEFD-\\uFF0F\\uFF1A-\\uFF20\\uFF3B-\\uFF3E\\uFF40\\uFF5B-\\uFF65\\uFFBF-\\uFFC1\\uFFC8\\uFFC9\\uFFD0\\uFFD1\\uFFD8\\uFFD9\\uFFDD-\\uFFFF]|\\uD800[\\uDC0C\\uDC27\\uDC3B\\uDC3E\\uDC4E\\uDC4F\\uDC5E-\\uDC7F\\uDCFB-\\uDD3F\\uDD75-\\uDDFC\\uDDFE-\\uDE7F\\uDE9D-\\uDE9F\\uDED1-\\uDEDF\\uDEE1-\\uDEFF\\uDF20-\\uDF2C\\uDF4B-\\uDF4F\\uDF7B-\\uDF7F\\uDF9E\\uDF9F\\uDFC4-\\uDFC7\\uDFD0\\uDFD6-\\uDFFF]|\\uD801[\\uDC9E\\uDC9F\\uDCAA-\\uDCAF\\uDCD4-\\uDCD7\\uDCFC-\\uDCFF\\uDD28-\\uDD2F\\uDD64-\\uDDFF\\uDF37-\\uDF3F\\uDF56-\\uDF5F\\uDF68-\\uDFFF]|\\uD802[\\uDC06\\uDC07\\uDC09\\uDC36\\uDC39-\\uDC3B\\uDC3D\\uDC3E\\uDC56-\\uDC5F\\uDC77-\\uDC7F\\uDC9F-\\uDCDF\\uDCF3\\uDCF6-\\uDCFF\\uDD16-\\uDD1F\\uDD3A-\\uDD7F\\uDDB8-\\uDDBD\\uDDC0-\\uDDFF\\uDE04\\uDE07-\\uDE0B\\uDE14\\uDE18\\uDE36\\uDE37\\uDE3B-\\uDE3E\\uDE40-\\uDE5F\\uDE7D-\\uDE7F\\uDE9D-\\uDEBF\\uDEC8\\uDEE7-\\uDEFF\\uDF36-\\uDF3F\\uDF56-\\uDF5F\\uDF73-\\uDF7F\\uDF92-\\uDFFF]|\\uD803[\\uDC49-\\uDC7F\\uDCB3-\\uDCBF\\uDCF3-\\uDCFF\\uDD28-\\uDD2F\\uDD3A-\\uDE7F\\uDEAA\\uDEAD-\\uDEAF\\uDEB2-\\uDEFF\\uDF1D-\\uDF26\\uDF28-\\uDF2F\\uDF51-\\uDFAF\\uDFC5-\\uDFDF\\uDFF7-\\uDFFF]|\\uD804[\\uDC47-\\uDC65\\uDC70-\\uDC7E\\uDCBB-\\uDCCF\\uDCE9-\\uDCEF\\uDCFA-\\uDCFF\\uDD35\\uDD40-\\uDD43\\uDD48-\\uDD4F\\uDD74\\uDD75\\uDD77-\\uDD7F\\uDDC5-\\uDDC8\\uDDCD\\uDDDB\\uDDDD-\\uDDFF\\uDE12\\uDE38-\\uDE3D\\uDE3F-\\uDE7F\\uDE87\\uDE89\\uDE8E\\uDE9E\\uDEA9-\\uDEAF\\uDEEB-\\uDEEF\\uDEFA-\\uDEFF\\uDF04\\uDF0D\\uDF0E\\uDF11\\uDF12\\uDF29\\uDF31\\uDF34\\uDF3A\\uDF45\\uDF46\\uDF49\\uDF4A\\uDF4E\\uDF4F\\uDF51-\\uDF56\\uDF58-\\uDF5C\\uDF64\\uDF65\\uDF6D-\\uDF6F\\uDF75-\\uDFFF]|\\uD805[\\uDC4B-\\uDC4F\\uDC5A-\\uDC5D\\uDC62-\\uDC7F\\uDCC6\\uDCC8-\\uDCCF\\uDCDA-\\uDD7F\\uDDB6\\uDDB7\\uDDC1-\\uDDD7\\uDDDE-\\uDDFF\\uDE41-\\uDE43\\uDE45-\\uDE4F\\uDE5A-\\uDE7F\\uDEB9-\\uDEBF\\uDECA-\\uDEFF\\uDF1B\\uDF1C\\uDF2C-\\uDF2F\\uDF3A-\\uDFFF]|\\uD806[\\uDC3B-\\uDC9F\\uDCEA-\\uDCFE\\uDD07\\uDD08\\uDD0A\\uDD0B\\uDD14\\uDD17\\uDD36\\uDD39\\uDD3A\\uDD44-\\uDD4F\\uDD5A-\\uDD9F\\uDDA8\\uDDA9\\uDDD8\\uDDD9\\uDDE2\\uDDE5-\\uDDFF\\uDE3F-\\uDE46\\uDE48-\\uDE4F\\uDE9A-\\uDE9C\\uDE9E-\\uDEBF\\uDEF9-\\uDFFF]|\\uD807[\\uDC09\\uDC37\\uDC41-\\uDC4F\\uDC5A-\\uDC71\\uDC90\\uDC91\\uDCA8\\uDCB7-\\uDCFF\\uDD07\\uDD0A\\uDD37-\\uDD39\\uDD3B\\uDD3E\\uDD48-\\uDD4F\\uDD5A-\\uDD5F\\uDD66\\uDD69\\uDD8F\\uDD92\\uDD99-\\uDD9F\\uDDAA-\\uDEDF\\uDEF7-\\uDFAF\\uDFB1-\\uDFFF]|\\uD808[\\uDF9A-\\uDFFF]|\\uD809[\\uDC6F-\\uDC7F\\uDD44-\\uDFFF]|[\\uD80A\\uD80B\\uD80E-\\uD810\\uD812-\\uD819\\uD824-\\uD82B\\uD82D\\uD82E\\uD830-\\uD833\\uD837\\uD839\\uD83D\\uD83F\\uD87B-\\uD87D\\uD87F\\uD885-\\uDB3F\\uDB41-\\uDBFF][\\uDC00-\\uDFFF]|\\uD80D[\\uDC2F-\\uDFFF]|\\uD811[\\uDE47-\\uDFFF]|\\uD81A[\\uDE39-\\uDE3F\\uDE5F\\uDE6A-\\uDECF\\uDEEE\\uDEEF\\uDEF5-\\uDEFF\\uDF37-\\uDF3F\\uDF44-\\uDF4F\\uDF5A-\\uDF62\\uDF78-\\uDF7C\\uDF90-\\uDFFF]|\\uD81B[\\uDC00-\\uDE3F\\uDE80-\\uDEFF\\uDF4B-\\uDF4E\\uDF88-\\uDF8E\\uDFA0-\\uDFDF\\uDFE2\\uDFE5-\\uDFEF\\uDFF2-\\uDFFF]|\\uD821[\\uDFF8-\\uDFFF]|\\uD823[\\uDCD6-\\uDCFF\\uDD09-\\uDFFF]|\\uD82C[\\uDD1F-\\uDD4F\\uDD53-\\uDD63\\uDD68-\\uDD6F\\uDEFC-\\uDFFF]|\\uD82F[\\uDC6B-\\uDC6F\\uDC7D-\\uDC7F\\uDC89-\\uDC8F\\uDC9A-\\uDC9C\\uDC9F-\\uDFFF]|\\uD834[\\uDC00-\\uDD64\\uDD6A-\\uDD6C\\uDD73-\\uDD7A\\uDD83\\uDD84\\uDD8C-\\uDDA9\\uDDAE-\\uDE41\\uDE45-\\uDFFF]|\\uD835[\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDEC1\\uDEDB\\uDEFB\\uDF15\\uDF35\\uDF4F\\uDF6F\\uDF89\\uDFA9\\uDFC3\\uDFCC\\uDFCD]|\\uD836[\\uDC00-\\uDDFF\\uDE37-\\uDE3A\\uDE6D-\\uDE74\\uDE76-\\uDE83\\uDE85-\\uDE9A\\uDEA0\\uDEB0-\\uDFFF]|\\uD838[\\uDC07\\uDC19\\uDC1A\\uDC22\\uDC25\\uDC2B-\\uDCFF\\uDD2D-\\uDD2F\\uDD3E\\uDD3F\\uDD4A-\\uDD4D\\uDD4F-\\uDEBF\\uDEFA-\\uDFFF]|\\uD83A[\\uDCC5-\\uDCCF\\uDCD7-\\uDCFF\\uDD4C-\\uDD4F\\uDD5A-\\uDFFF]|\\uD83B[\\uDC00-\\uDDFF\\uDE04\\uDE20\\uDE23\\uDE25\\uDE26\\uDE28\\uDE33\\uDE38\\uDE3A\\uDE3C-\\uDE41\\uDE43-\\uDE46\\uDE48\\uDE4A\\uDE4C\\uDE50\\uDE53\\uDE55\\uDE56\\uDE58\\uDE5A\\uDE5C\\uDE5E\\uDE60\\uDE63\\uDE65\\uDE66\\uDE6B\\uDE73\\uDE78\\uDE7D\\uDE7F\\uDE8A\\uDE9C-\\uDEA0\\uDEA4\\uDEAA\\uDEBC-\\uDFFF]|\\uD83C[\\uDC00-\\uDD2F\\uDD4A-\\uDD4F\\uDD6A-\\uDD6F\\uDD8A-\\uDFFF]|\\uD83E[\\uDC00-\\uDFEF\\uDFFA-\\uDFFF]|\\uD869[\\uDEDE-\\uDEFF]|\\uD86D[\\uDF35-\\uDF3F]|\\uD86E[\\uDC1E\\uDC1F]|\\uD873[\\uDEA2-\\uDEAF]|\\uD87A[\\uDFE1-\\uDFFF]|\\uD87E[\\uDE1E-\\uDFFF]|\\uD884[\\uDF4B-\\uDFFF]|\\uDB40[\\uDC00-\\uDCFF\\uDDF0-\\uDFFF]/g\n","/**\n * Transform a string into an applicable expression.\n *\n * @param {string} value\n * @returns {RegExp}\n */\nexport function toExpression(value) {\n  return new RegExp('^(' + value + ')$', 'i')\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('./search.js').SearchEntry} SearchEntry\n */\n\n/**\n * @typedef ContentsOptions\n *   Build configuration.\n * @property {boolean | null | undefined} [tight=false]\n *   Whether to compile list items tightly.\n * @property {boolean | null | undefined} [ordered=false]\n *   Whether to compile list items as an ordered list, otherwise they are\n *   unordered.\n * @property {string | null | undefined} [prefix=undefined]\n *   Add a prefix to links to headings in the table of contents.\n *\n *   Useful for example when later going from mdast to hast and sanitizing with\n *   `hast-util-sanitize`.\n */\n\nimport extend from 'extend'\n\n/**\n * Transform a list of heading objects to a markdown list.\n *\n * @param {Array<SearchEntry>} map\n * @param {ContentsOptions} settings\n */\nexport function contents(map, settings) {\n  const {ordered = false, tight = false, prefix = null} = settings\n  /** @type {List} */\n  const table = {type: 'list', ordered, spread: false, children: []}\n  let minDepth = Number.POSITIVE_INFINITY\n  let index = -1\n\n  // Find minimum depth.\n  while (++index < map.length) {\n    if (map[index].depth < minDepth) {\n      minDepth = map[index].depth\n    }\n  }\n\n  // Normalize depth.\n  index = -1\n\n  while (++index < map.length) {\n    map[index].depth -= minDepth - 1\n  }\n\n  // Add TOC to list.\n  index = -1\n\n  while (++index < map.length) {\n    insert(map[index], table, {ordered, tight, prefix})\n  }\n\n  return table\n}\n\n/**\n * Insert an entry into `parent`.\n *\n * @param {SearchEntry} entry\n * @param {List | ListItem} parent\n * @param {ContentsOptions} settings\n */\nfunction insert(entry, parent, settings) {\n  let index = -1\n  const tail = parent.children[parent.children.length - 1]\n\n  if (parent.type === 'list') {\n    if (entry.depth === 1) {\n      parent.children.push({\n        type: 'listItem',\n        spread: false,\n        children: [\n          {\n            type: 'paragraph',\n            children: [\n              {\n                type: 'link',\n                title: null,\n                url: '#' + (settings.prefix || '') + entry.id,\n                children: all(entry.children)\n              }\n            ]\n          }\n        ]\n      })\n    } else if (parent.children.length > 0) {\n      const tail = parent.children[parent.children.length - 1]\n      insert(entry, tail, settings)\n    } else {\n      /** @type {ListItem} */\n      const item = {type: 'listItem', spread: false, children: []}\n      parent.children.push(item)\n      insert(entry, item, settings)\n    }\n  }\n  // List item\n  else if (tail && tail.type === 'list') {\n    entry.depth--\n    insert(entry, tail, settings)\n  } else {\n    /** @type {List} */\n    const item = {\n      type: 'list',\n      ordered: settings.ordered,\n      spread: false,\n      children: []\n    }\n    parent.children.push(item)\n    entry.depth--\n    insert(entry, item, settings)\n  }\n\n  if (parent.type === 'list' && !settings.tight) {\n    parent.spread = false\n\n    while (++index < parent.children.length) {\n      if (parent.children[index].children.length > 1) {\n        parent.spread = true\n        break\n      }\n    }\n  } else {\n    parent.spread = !settings.tight\n  }\n}\n\n/**\n * @param {Array<PhrasingContent>} [nodes]\n * @returns {Array<StaticPhrasingContent>}\n */\nfunction all(nodes) {\n  /** @type {Array<StaticPhrasingContent>} */\n  let result = []\n  let index = -1\n\n  if (nodes) {\n    while (++index < nodes.length) {\n      result = result.concat(one(nodes[index]))\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {PhrasingContent} node\n * @returns {StaticPhrasingContent | Array<StaticPhrasingContent>}\n */\nfunction one(node) {\n  if (node.type === 'footnoteReference') {\n    return []\n  }\n\n  if (\n    node.type === 'link' ||\n    node.type === 'linkReference' ||\n    node.type === 'footnote'\n  ) {\n    return all(node.children)\n  }\n\n  if ('children' in node) {\n    const {children, position, ...copy} = node\n    return Object.assign(extend(true, {}, copy), {children: all(node.children)})\n  }\n\n  const {position, ...copy} = node\n  return extend(true, {}, copy)\n}\n","/**\n * @typedef {import('unist').Node} Node\n */\n\n/**\n * @typedef {Array<Node> | string} ChildrenOrValue\n *   List to use as `children` or value to use as `value`.\n *\n * @typedef {Record<string, unknown>} Props\n *   Other fields to add to the node.\n */\n\n/**\n * Build a node.\n *\n * @param type\n *   Node type.\n * @param props\n *   Fields assigned to node.\n * @param value\n *   Children of node or value of `node` (cast to string).\n * @returns\n *   Built node.\n */\nexport const u =\n  /**\n   * @type {(\n   *   (<T extends string>(type: T) => {type: T}) &\n   *   (<T extends string, P extends Props>(type: T, props: P) => {type: T} & P) &\n   *   (<T extends string>(type: T, value: string) => {type: T, value: string}) &\n   *   (<T extends string, P extends Props>(type: T, props: P, value: string) => {type: T, value: string} & P) &\n   *   (<T extends string, C extends Array<Node>>(type: T, children: C) => {type: T, children: C}) &\n   *   (<T extends string, P extends Props, C extends Array<Node>>(type: T, props: P, children: C) => {type: T, children: C} & P)\n   * )}\n   */\n  (\n    /**\n     * @param {string} type\n     * @param {Props | ChildrenOrValue | null | undefined} [props]\n     * @param {ChildrenOrValue | null | undefined} [value]\n     * @returns {Node}\n     */\n    function (type, props, value) {\n      /** @type {Node} */\n      const node = {type: String(type)}\n\n      if (\n        (value === undefined || value === null) &&\n        (typeof props === 'string' || Array.isArray(props))\n      ) {\n        value = props\n      } else {\n        Object.assign(node, props)\n      }\n\n      if (Array.isArray(value)) {\n        // @ts-expect-error: create a parent.\n        node.children = value\n      } else if (value !== undefined && value !== null) {\n        // @ts-expect-error: create a literal.\n        node.value = String(value)\n      }\n\n      return node\n    }\n  )\n","import isTocStart from './isTocStart.js';\nimport isTocEnd from '../isTocEnd.js';\n\nexport default (tree) => tree.children.reduce(\n  (seed, part) => {\n    if (seed.tocStart && !seed.isInToc) { return seed; }\n    if (isTocEnd(part)) { return { ...seed, isInToc: false }; }\n    if (isTocStart(part)) {\n      return {\n        ...seed,\n        tocStart: part,\n        tocStartIndex: seed.tocStartIndex,\n        isInToc: true,\n      };\n    }\n\n    return seed.isInToc\n      ? { ...seed, tocContent: [ ...seed.tocContent, part ], tocSize: seed.tocSize + 1 }\n      : { ...seed, tocStartIndex: seed.tocStartIndex + 1 };\n  },\n  {\n    tocStartIndex: 0,\n    tocSize: 0,\n    tocStart: undefined,\n    tocContent: [],\n    isInToc: false,\n  },\n);\n","import { TOC_START_MATCHER } from '../../constants.js';\n\nexport default (part) => part.type === 'html' && TOC_START_MATCHER.test(part.value);\n","export const homePage = 'https://github.com/quilicicf/markdown-formatter'; // NOTE: must be the same as in package.json\nexport const bugPage = 'https://github.com/quilicicf/markdown-formatter/issues'; // NOTE: must be the same as in package.json\n\nexport const DEFAULT_TOC_OPTIONS = { min: 2, max: 4 };\nexport const TOC_START_MATCHER = /^<!-- TOC START(.*) -->$/;\nexport const TOC_END_MATCHER = /^<!-- TOC END(.*) -->$/;\n\nexport const WATERMARK_VALUES = {\n  NONE: 'none',\n  TOP: 'top',\n  TOC: 'toc',\n};\n\nexport const WATERMARK_TOP = `<!-- Formatted by ${homePage} -->`;\nexport const WATERMARK_TOC = `<!-- TOC END: Formatted by ${homePage} -->`;\n\nexport const DEFAULT_MARKDOWN_FORMATTER_OPTIONS = {\n  watermark: WATERMARK_VALUES.NONE,\n};\n\nexport const DEFAULT_STRINGIFY_OPTIONS = {\n  bullet: '*',\n  emphasis: '_',\n  fences: true,\n  gfm: true,\n  listItemIndent: '1',\n  rule: '-',\n  ruleSpaces: false,\n  strong: '_',\n};\n","import { TOC_END_MATCHER } from '../constants.js';\n\nexport default (part) => part.type === 'html' && TOC_END_MATCHER.test(part.value);\n","import matchAll from '../../matchAll.js';\nimport { TOC_START_MATCHER } from '../../constants.js';\n\nconst CONFIG_CLEANERS = {\n  min (minAsString) {\n    try {\n      return parseInt(minAsString, 10);\n    } catch (error) {\n      throw Error(`Min must be a number, got ${minAsString}`);\n    }\n  },\n  max (maxAsString) {\n    try {\n      return parseInt(maxAsString, 10);\n    } catch (error) {\n      throw Error(`Min must be a number, got ${maxAsString}`);\n    }\n  },\n};\n\nexport default (tocStart) => {\n  const configAsString = TOC_START_MATCHER.exec(tocStart)[ 1 ];\n  const configItems = matchAll(\n    /([^\\s:]+):([^\\s]+)/g,\n    configAsString,\n    (match) => ({ key: match[ 1 ], value: match[ 2 ] }),\n  );\n  return configItems\n    .map((configItem) => {\n      if (!CONFIG_CLEANERS[ configItem.key ]) {\n        return configItem;\n      }\n\n      try {\n        return {\n          key: configItem.key,\n          value: CONFIG_CLEANERS[ configItem.key ](configItem.value),\n        };\n      } catch (error) {\n        process.stderr.write(error.message);\n        return {};\n      }\n    })\n    .filter(Boolean)\n    .reduce(\n      (seed, { value, key }) => ({ ...seed, [ key ]: value }),\n      {},\n    );\n};\n","/**\n * Takes a GLOBAL (add flag g) regex and executes it against the same string as long as it yields results.\n * The exec results are handled by the given matchHandler and returned in an array.\n */\nconst matchAll = (regex, string, matchHandler = (i) => i, currentMatches = []) => {\n  const nextMatch = regex.exec(string);\n\n  if (!nextMatch) { return currentMatches; }\n\n  return [\n    ...matchAll(regex, string, matchHandler, [ ...currentMatches, matchHandler(nextMatch) ]),\n  ];\n};\n\nexport default matchAll;\n","export default (number, { min, max }) => number >= min && number <= max;\n","import { WATERMARK_TOP, WATERMARK_VALUES } from '../../constants.js';\n\nimport addWatermarkInTocEnd from './addWatermarkInTocEnd.js';\nimport searchAndDestroyWatermarkTop from './searchAndDestroyWatermarkTop.js';\n\nexport default (watermarkType) => (\n  () => (\n    (tree, file) => {\n      searchAndDestroyWatermarkTop(tree, file);\n      if (watermarkType === WATERMARK_VALUES.NONE) { return; }\n      if (watermarkType === WATERMARK_VALUES.TOP) { tree.children.splice(0, 0, { type: 'html', value: WATERMARK_TOP }); }\n      if (watermarkType === WATERMARK_VALUES.TOC) { addWatermarkInTocEnd(tree); }\n    }\n  )\n);\n","import isTocEnd from '../isTocEnd.js';\nimport { WATERMARK_TOC } from '../../constants.js';\n\nexport default (tree) => {\n  const tocEnd = tree.children.find((part) => isTocEnd(part));\n  if (tocEnd) { tocEnd.value = WATERMARK_TOC; }\n};\n","import { WATERMARK_TOP } from '../../constants.js';\n\nconst isWatermarkTop = (part) => part.type === 'html' && part.value === WATERMARK_TOP;\n\nexport default (tree, file) => {\n  const watermarkIndex = tree.children // Watermark can be moved by user\n    .map((part, index) => ({ part, index }))\n    .filter(({ part }) => isWatermarkTop(part))\n    .map(({ index }) => index)\n    .find(() => true);\n\n  if (typeof watermarkIndex === 'number') {\n    file.info(`Watermark found at index ${watermarkIndex}, destroying it to replace it`);\n    tree.children.splice(watermarkIndex, 1);\n  }\n};\n"],"names":[],"version":3,"file":"formatFromString.js.map"}